/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.7.0 (NJsonSchema v9.13.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    isTenantAvailable(input: IsTenantAvailableInput | null | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    register(input: RegisterInput | null | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changePassword(input: ChangePasswordDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Account/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetPassword(input: ResetPasswordInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getInfo(): Observable<GetInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Account/GetInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInfo(<any>response_);
                } catch (e) {
                    return <Observable<GetInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInfo(response: HttpResponseBase): Observable<GetInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetInfoDto.fromJS(resultData200) : new GetInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInfoDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateInfo(input: UpdateInfoDto | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Account/UpdateInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateInfo(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateInfo(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendActiveCode(input: SendActiveCodeInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendActiveCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendActiveCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendActiveCode(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSendActiveCode(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    activeAccount(input: ActiveAccountInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Account/ActiveAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActiveAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActiveAccount(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processActiveAccount(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeUiTheme(input: ChangeUiThemeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CongViecServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAll(input: DanhSachCongViecInput | null | undefined): Observable<CongViecDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CongViec/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CongViecDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CongViecDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CongViecDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CongViecDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CongViecDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<CongViecDto> {
        let url_ = this.baseUrl + "/api/services/app/CongViec/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CongViecDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CongViecDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CongViecDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CongViecDto.fromJS(resultData200) : new CongViecDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CongViecDto>(<any>null);
    }

    /**
     * @return Success
     */
    getTotal(): Observable<GetTotalOutput> {
        let url_ = this.baseUrl + "/api/services/app/CongViec/GetTotal";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTotal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTotal(<any>response_);
                } catch (e) {
                    return <Observable<GetTotalOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTotalOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTotal(response: HttpResponseBase): Observable<GetTotalOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTotalOutput.fromJS(resultData200) : new GetTotalOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTotalOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateYeuCauDto | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CongViec/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    nhanViec(input: NhanViecInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CongViec/NhanViec";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNhanViec(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNhanViec(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processNhanViec(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    capNhatLocation(input: CapNhatLocationInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CongViec/CapNhatLocation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCapNhatLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCapNhatLocation(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCapNhatLocation(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    traVeTramTruong(input: TraVeTramTruongInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CongViec/TraVeTramTruong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTraVeTramTruong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTraVeTramTruong(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processTraVeTramTruong(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    phanLoaiCongViec(input: PhanLoaiCongViecInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CongViec/PhanLoaiCongViec";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPhanLoaiCongViec(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPhanLoaiCongViec(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPhanLoaiCongViec(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    baoGiaCongViec(input: BaoGiaCongViecInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CongViec/BaoGiaCongViec";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBaoGiaCongViec(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBaoGiaCongViec(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processBaoGiaCongViec(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hoanThanhCongViec(input: HoanThanhCongViecInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CongViec/HoanThanhCongViec";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHoanThanhCongViec(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHoanThanhCongViec(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processHoanThanhCongViec(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    khachHangHuy(input: KhachHangHuyInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CongViec/KhachHangHuy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKhachHangHuy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKhachHangHuy(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processKhachHangHuy(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    khachHangDanhGia(input: KhachHangDanhGiaInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CongViec/KhachHangDanhGia";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKhachHangDanhGia(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKhachHangDanhGia(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processKhachHangDanhGia(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param listNameFileUpload (optional) 
     * @return Success
     */
    getTotalDuplicateFile(id: number | null | undefined, listNameFileUpload: string[] | null | undefined): Observable<DuplicateThongTinSampleOutput> {
        let url_ = this.baseUrl + "/api/services/app/CongViec/GetTotalDuplicateFile?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (listNameFileUpload !== undefined)
            listNameFileUpload && listNameFileUpload.forEach(item => { url_ += "ListNameFileUpload=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTotalDuplicateFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTotalDuplicateFile(<any>response_);
                } catch (e) {
                    return <Observable<DuplicateThongTinSampleOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DuplicateThongTinSampleOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTotalDuplicateFile(response: HttpResponseBase): Observable<DuplicateThongTinSampleOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DuplicateThongTinSampleOutput.fromJS(resultData200) : new DuplicateThongTinSampleOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DuplicateThongTinSampleOutput>(<any>null);
    }
}

@Injectable()
export class DanhMucDichVuServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param nhomDichVuId (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, nhomDichVuId: number | null | undefined, isActive: boolean | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfDanhMucDichVuDto> {
        let url_ = this.baseUrl + "/api/services/app/DanhMucDichVu/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (nhomDichVuId !== undefined)
            url_ += "NhomDichVuId=" + encodeURIComponent("" + nhomDichVuId) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDanhMucDichVuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDanhMucDichVuDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDanhMucDichVuDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDanhMucDichVuDto.fromJS(resultData200) : new PagedResultDtoOfDanhMucDichVuDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDanhMucDichVuDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: DanhMucDichVuDto | null | undefined): Observable<DanhMucDichVuDto> {
        let url_ = this.baseUrl + "/api/services/app/DanhMucDichVu/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<DanhMucDichVuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DanhMucDichVuDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DanhMucDichVuDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DanhMucDichVuDto.fromJS(resultData200) : new DanhMucDichVuDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DanhMucDichVuDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<DanhMucDichVuDto> {
        let url_ = this.baseUrl + "/api/services/app/DanhMucDichVu/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DanhMucDichVuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DanhMucDichVuDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DanhMucDichVuDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DanhMucDichVuDto.fromJS(resultData200) : new DanhMucDichVuDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DanhMucDichVuDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateDanhMucDichVuDto | null | undefined): Observable<DanhMucDichVuDto> {
        let url_ = this.baseUrl + "/api/services/app/DanhMucDichVu/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<DanhMucDichVuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DanhMucDichVuDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DanhMucDichVuDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DanhMucDichVuDto.fromJS(resultData200) : new DanhMucDichVuDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DanhMucDichVuDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DanhMucDichVu/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DanhMucHangServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: DanhMucHangDto | null | undefined): Observable<DanhMucHangDto> {
        let url_ = this.baseUrl + "/api/services/app/DanhMucHang/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<DanhMucHangDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DanhMucHangDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DanhMucHangDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DanhMucHangDto.fromJS(resultData200) : new DanhMucHangDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DanhMucHangDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<DanhMucHangDto> {
        let url_ = this.baseUrl + "/api/services/app/DanhMucHang/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DanhMucHangDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DanhMucHangDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DanhMucHangDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DanhMucHangDto.fromJS(resultData200) : new DanhMucHangDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DanhMucHangDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfDanhMucHangDto> {
        let url_ = this.baseUrl + "/api/services/app/DanhMucHang/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDanhMucHangDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDanhMucHangDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDanhMucHangDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDanhMucHangDto.fromJS(resultData200) : new PagedResultDtoOfDanhMucHangDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDanhMucHangDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateDanhMucHangDto | null | undefined): Observable<DanhMucHangDto> {
        let url_ = this.baseUrl + "/api/services/app/DanhMucHang/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<DanhMucHangDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DanhMucHangDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DanhMucHangDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DanhMucHangDto.fromJS(resultData200) : new DanhMucHangDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DanhMucHangDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DanhMucHang/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DanhMucHangMucServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param nhomDichVuId (optional) 
     * @param dichVuId (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, nhomDichVuId: number | null | undefined, dichVuId: number | null | undefined, isActive: boolean | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfDanhMucHangMucDto> {
        let url_ = this.baseUrl + "/api/services/app/DanhMucHangMuc/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (nhomDichVuId !== undefined)
            url_ += "NhomDichVuId=" + encodeURIComponent("" + nhomDichVuId) + "&"; 
        if (dichVuId !== undefined)
            url_ += "DichVuId=" + encodeURIComponent("" + dichVuId) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDanhMucHangMucDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDanhMucHangMucDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDanhMucHangMucDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDanhMucHangMucDto.fromJS(resultData200) : new PagedResultDtoOfDanhMucHangMucDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDanhMucHangMucDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<DanhMucHangMucDto> {
        let url_ = this.baseUrl + "/api/services/app/DanhMucHangMuc/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DanhMucHangMucDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DanhMucHangMucDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DanhMucHangMucDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DanhMucHangMucDto.fromJS(resultData200) : new DanhMucHangMucDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DanhMucHangMucDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: DanhMucHangMucDto | null | undefined): Observable<DanhMucHangMucDto> {
        let url_ = this.baseUrl + "/api/services/app/DanhMucHangMuc/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<DanhMucHangMucDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DanhMucHangMucDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DanhMucHangMucDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DanhMucHangMucDto.fromJS(resultData200) : new DanhMucHangMucDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DanhMucHangMucDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateDanhMucHangMucDto | null | undefined): Observable<DanhMucHangMucDto> {
        let url_ = this.baseUrl + "/api/services/app/DanhMucHangMuc/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<DanhMucHangMucDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DanhMucHangMucDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DanhMucHangMucDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DanhMucHangMucDto.fromJS(resultData200) : new DanhMucHangMucDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DanhMucHangMucDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DanhMucHangMuc/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DanhMucNhomDichVuServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: DanhMucNhomDichVuDto | null | undefined): Observable<DanhMucNhomDichVuDto> {
        let url_ = this.baseUrl + "/api/services/app/DanhMucNhomDichVu/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<DanhMucNhomDichVuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DanhMucNhomDichVuDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DanhMucNhomDichVuDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DanhMucNhomDichVuDto.fromJS(resultData200) : new DanhMucNhomDichVuDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DanhMucNhomDichVuDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<DanhMucNhomDichVuDto> {
        let url_ = this.baseUrl + "/api/services/app/DanhMucNhomDichVu/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DanhMucNhomDichVuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DanhMucNhomDichVuDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DanhMucNhomDichVuDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DanhMucNhomDichVuDto.fromJS(resultData200) : new DanhMucNhomDichVuDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DanhMucNhomDichVuDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfDanhMucNhomDichVuDto> {
        let url_ = this.baseUrl + "/api/services/app/DanhMucNhomDichVu/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDanhMucNhomDichVuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDanhMucNhomDichVuDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDanhMucNhomDichVuDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDanhMucNhomDichVuDto.fromJS(resultData200) : new PagedResultDtoOfDanhMucNhomDichVuDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDanhMucNhomDichVuDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateDanhMucNhomDichVuDto | null | undefined): Observable<DanhMucNhomDichVuDto> {
        let url_ = this.baseUrl + "/api/services/app/DanhMucNhomDichVu/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<DanhMucNhomDichVuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DanhMucNhomDichVuDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DanhMucNhomDichVuDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DanhMucNhomDichVuDto.fromJS(resultData200) : new DanhMucNhomDichVuDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DanhMucNhomDichVuDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DanhMucNhomDichVu/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class HeThongServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getDieuKhoanSuDung(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/HeThong/GetDieuKhoanSuDung";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDieuKhoanSuDung(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDieuKhoanSuDung(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetDieuKhoanSuDung(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createDieuKhoanSuDung(input: CreateDieuKhoanSuDungDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HeThong/CreateDieuKhoanSuDung";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDieuKhoanSuDung(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDieuKhoanSuDung(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDieuKhoanSuDung(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getThongTinHeThong(): Observable<ThongTinHeThongDto> {
        let url_ = this.baseUrl + "/api/services/app/HeThong/GetThongTinHeThong";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThongTinHeThong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThongTinHeThong(<any>response_);
                } catch (e) {
                    return <Observable<ThongTinHeThongDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ThongTinHeThongDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetThongTinHeThong(response: HttpResponseBase): Observable<ThongTinHeThongDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ThongTinHeThongDto.fromJS(resultData200) : new ThongTinHeThongDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThongTinHeThongDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createThongTinHeThong(input: ThongTinHeThongDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HeThong/CreateThongTinHeThong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateThongTinHeThong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateThongTinHeThong(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateThongTinHeThong(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ImportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    congViec(): Observable<string> {
        let url_ = this.baseUrl + "/api/Import/CongViec";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCongViec(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCongViec(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCongViec(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    khachHang(): Observable<string> {
        let url_ = this.baseUrl + "/api/Import/KhachHang";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKhachHang(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKhachHang(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processKhachHang(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class KhachHangServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfKhachHangDto> {
        let url_ = this.baseUrl + "/api/services/app/KhachHang/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfKhachHangDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfKhachHangDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfKhachHangDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfKhachHangDto.fromJS(resultData200) : new PagedResultDtoOfKhachHangDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfKhachHangDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<KhachHangDto> {
        let url_ = this.baseUrl + "/api/services/app/KhachHang/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<KhachHangDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<KhachHangDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<KhachHangDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? KhachHangDto.fromJS(resultData200) : new KhachHangDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KhachHangDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateKhachHangDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KhachHang/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: KhachHangDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KhachHang/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KhachHang/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    activeAccount(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KhachHang/ActiveAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActiveAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActiveAccount(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActiveAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    lockUnlockAccount(input: LockUnlockInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KhachHang/LockUnlockAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLockUnlockAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLockUnlockAccount(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLockUnlockAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setPassword(input: SetPasswordDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KhachHang/SetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createAccount(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KhachHang/CreateAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAccount(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param fileName (optional) 
     * @return Success
     */
    importFileExcel(fileName: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/KhachHang/ImportFileExcel?";
        if (fileName !== undefined)
            url_ += "FileName=" + encodeURIComponent("" + fileName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportFileExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportFileExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processImportFileExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    downloadFileMau(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/KhachHang/DownloadFileMau";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileMau(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileMau(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileMau(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class KhuyenMaiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<KhuyenMaiDto[]> {
        let url_ = this.baseUrl + "/api/services/app/KhuyenMai/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<KhuyenMaiDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<KhuyenMaiDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<KhuyenMaiDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(KhuyenMaiDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KhuyenMaiDto[]>(<any>null);
    }
}

@Injectable()
export class LookupTableServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tramDichVuId (optional) 
     * @return Success
     */
    getAllTramTruongForLookupTable(tramDichVuId: number | null | undefined): Observable<LookupTableDtoOfInt64[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllTramTruongForLookupTable?";
        if (tramDichVuId !== undefined)
            url_ += "TramDichVuId=" + encodeURIComponent("" + tramDichVuId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTramTruongForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTramTruongForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDtoOfInt64[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDtoOfInt64[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTramTruongForLookupTable(response: HttpResponseBase): Observable<LookupTableDtoOfInt64[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LookupTableDtoOfInt64.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDtoOfInt64[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTinhThanhForLookupTable(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllTinhThanhForLookupTable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTinhThanhForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTinhThanhForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTinhThanhForLookupTable(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllQuanHuyenForLookupTable(input: GetAllQuanHuyenInput | null | undefined): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllQuanHuyenForLookupTable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllQuanHuyenForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllQuanHuyenForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllQuanHuyenForLookupTable(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @param tramDichVuId (optional) 
     * @return Success
     */
    getAllNhanVienForLookupTable(tramDichVuId: number | null | undefined): Observable<NhanVienLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllNhanVienForLookupTable?";
        if (tramDichVuId !== undefined)
            url_ += "TramDichVuId=" + encodeURIComponent("" + tramDichVuId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNhanVienForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNhanVienForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<NhanVienLookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NhanVienLookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNhanVienForLookupTable(response: HttpResponseBase): Observable<NhanVienLookupTableDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NhanVienLookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhanVienLookupTableDto[]>(<any>null);
    }

    /**
     * @param tramDichVuId (optional) 
     * @return Success
     */
    getAllNhanVienByTramForLookupTable(tramDichVuId: number | null | undefined): Observable<NhanVienLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllNhanVienByTramForLookupTable?";
        if (tramDichVuId !== undefined)
            url_ += "TramDichVuId=" + encodeURIComponent("" + tramDichVuId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNhanVienByTramForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNhanVienByTramForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<NhanVienLookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NhanVienLookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNhanVienByTramForLookupTable(response: HttpResponseBase): Observable<NhanVienLookupTableDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NhanVienLookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhanVienLookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllKhachHangForLookupTable(): Observable<KhachHangLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllKhachHangForLookupTable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKhachHangForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKhachHangForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<KhachHangLookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<KhachHangLookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllKhachHangForLookupTable(response: HttpResponseBase): Observable<KhachHangLookupTableDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(KhachHangLookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KhachHangLookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTramDichVuForLookupTable(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllTramDichVuForLookupTable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTramDichVuForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTramDichVuForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTramDichVuForLookupTable(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllNhomDichVuForLookupTable(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllNhomDichVuForLookupTable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNhomDichVuForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNhomDichVuForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNhomDichVuForLookupTable(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @param nhomDichVuId (optional) 
     * @return Success
     */
    getAllDichVuForLookupTable(nhomDichVuId: number | null | undefined): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllDichVuForLookupTable?";
        if (nhomDichVuId !== undefined)
            url_ += "NhomDichVuId=" + encodeURIComponent("" + nhomDichVuId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDichVuForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDichVuForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDichVuForLookupTable(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }

    /**
     * @param dichVuId (optional) 
     * @return Success
     */
    getAllHangMucForLookupTable(dichVuId: number | null | undefined): Observable<HangMucLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllHangMucForLookupTable?";
        if (dichVuId !== undefined)
            url_ += "DichVuId=" + encodeURIComponent("" + dichVuId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHangMucForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHangMucForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<HangMucLookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HangMucLookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHangMucForLookupTable(response: HttpResponseBase): Observable<HangMucLookupTableDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HangMucLookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HangMucLookupTableDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTrangThaiCongViecForLookupTable(): Observable<LookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LookupTable/GetAllTrangThaiCongViecForLookupTable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTrangThaiCongViecForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTrangThaiCongViecForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<LookupTableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupTableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTrangThaiCongViecForLookupTable(response: HttpResponseBase): Observable<LookupTableDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LookupTableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupTableDto[]>(<any>null);
    }
}

@Injectable()
export class QuanLyCongViecServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param tramDichVuId (optional) 
     * @param trangThaiId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, tramDichVuId: number | null | undefined, trangThaiId: number | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCongViecDto> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyCongViec/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (tramDichVuId !== undefined)
            url_ += "TramDichVuId=" + encodeURIComponent("" + tramDichVuId) + "&"; 
        if (trangThaiId !== undefined)
            url_ += "TrangThaiId=" + encodeURIComponent("" + trangThaiId) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCongViecDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCongViecDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfCongViecDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCongViecDto.fromJS(resultData200) : new PagedResultDtoOfCongViecDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCongViecDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateCongViecDto | null | undefined): Observable<CongViecDto> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyCongViec/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CongViecDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CongViecDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CongViecDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CongViecDto.fromJS(resultData200) : new CongViecDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CongViecDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: CongViecDto | null | undefined): Observable<CongViecDto> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyCongViec/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<CongViecDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CongViecDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CongViecDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CongViecDto.fromJS(resultData200) : new CongViecDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CongViecDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<CongViecDto> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyCongViec/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CongViecDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CongViecDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CongViecDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CongViecDto.fromJS(resultData200) : new CongViecDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CongViecDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyCongViec/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    phanBoVeTram(input: PhanBoVeTramInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyCongViec/PhanBoVeTram";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPhanBoVeTram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPhanBoVeTram(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPhanBoVeTram(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    phanBoVeNhanVien(input: PhanBoVeNhanVienInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyCongViec/PhanBoVeNhanVien";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPhanBoVeNhanVien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPhanBoVeNhanVien(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPhanBoVeNhanVien(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    thuHoiCongViec(input: ThuHoiCongViecInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyCongViec/ThuHoiCongViec";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processThuHoiCongViec(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processThuHoiCongViec(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processThuHoiCongViec(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    huyBoCongViec(input: HuyBoCongViecInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyCongViec/HuyBoCongViec";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHuyBoCongViec(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHuyBoCongViec(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processHuyBoCongViec(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    xacNhanLinhKien(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyCongViec/XacNhanLinhKien";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXacNhanLinhKien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXacNhanLinhKien(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processXacNhanLinhKien(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    xacNhanHoanThanh(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyCongViec/XacNhanHoanThanh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXacNhanHoanThanh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXacNhanHoanThanh(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processXacNhanHoanThanh(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getTramIdMacDinh(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyCongViec/GetTramIdMacDinh";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTramIdMacDinh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTramIdMacDinh(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetTramIdMacDinh(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param fileName (optional) 
     * @return Success
     */
    importFileExcel(fileName: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyCongViec/ImportFileExcel?";
        if (fileName !== undefined)
            url_ += "FileName=" + encodeURIComponent("" + fileName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportFileExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportFileExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processImportFileExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    downloadFileMau(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyCongViec/DownloadFileMau";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileMau(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileMau(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileMau(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param listNameFileUpload (optional) 
     * @return Success
     */
    getTotalDuplicateFile(id: number | null | undefined, listNameFileUpload: string[] | null | undefined): Observable<DuplicateThongTinSampleOutput> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyCongViec/GetTotalDuplicateFile?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (listNameFileUpload !== undefined)
            listNameFileUpload && listNameFileUpload.forEach(item => { url_ += "ListNameFileUpload=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTotalDuplicateFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTotalDuplicateFile(<any>response_);
                } catch (e) {
                    return <Observable<DuplicateThongTinSampleOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DuplicateThongTinSampleOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTotalDuplicateFile(response: HttpResponseBase): Observable<DuplicateThongTinSampleOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DuplicateThongTinSampleOutput.fromJS(resultData200) : new DuplicateThongTinSampleOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DuplicateThongTinSampleOutput>(<any>null);
    }
}

@Injectable()
export class QuanLyKhuyenMaiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfTinTucDto> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyKhuyenMai/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTinTucDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTinTucDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfTinTucDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTinTucDto.fromJS(resultData200) : new PagedResultDtoOfTinTucDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTinTucDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<TinTucDto> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyKhuyenMai/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TinTucDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TinTucDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TinTucDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TinTucDto.fromJS(resultData200) : new TinTucDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TinTucDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateTinTucDto | null | undefined): Observable<TinTucDto> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyKhuyenMai/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<TinTucDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TinTucDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TinTucDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TinTucDto.fromJS(resultData200) : new TinTucDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TinTucDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: TinTucDto | null | undefined): Observable<TinTucDto> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyKhuyenMai/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<TinTucDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TinTucDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TinTucDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TinTucDto.fromJS(resultData200) : new TinTucDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TinTucDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuanLyKhuyenMai/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateRoleDto | null | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRolesAsync(permission: string | null | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRolesAsync?";
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolesAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolesAsync(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRolesAsync(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleListDto.fromJS(resultData200) : new ListResultDtoOfRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: RoleDto | null | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfPermissionDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfPermissionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfPermissionDto.fromJS(resultData200) : new ListResultDtoOfPermissionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfPermissionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfRoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRoleDto.fromJS(resultData200) : new PagedResultDtoOfRoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRoleDto>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }
}

@Injectable()
export class SoBaoHanhServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllNew(): Observable<SoBaoHanhDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SoBaoHanh/GetAllNew";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNew(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNew(<any>response_);
                } catch (e) {
                    return <Observable<SoBaoHanhDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SoBaoHanhDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNew(response: HttpResponseBase): Observable<SoBaoHanhDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SoBaoHanhDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SoBaoHanhDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<SoBaoHanhDto> {
        let url_ = this.baseUrl + "/api/services/app/SoBaoHanh/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<SoBaoHanhDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SoBaoHanhDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SoBaoHanhDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SoBaoHanhDto.fromJS(resultData200) : new SoBaoHanhDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SoBaoHanhDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateSoBaoHanhDto | null | undefined): Observable<SoBaoHanhDto> {
        let url_ = this.baseUrl + "/api/services/app/SoBaoHanh/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<SoBaoHanhDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SoBaoHanhDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SoBaoHanhDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SoBaoHanhDto.fromJS(resultData200) : new SoBaoHanhDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SoBaoHanhDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: SoBaoHanhDto | null | undefined): Observable<SoBaoHanhDto> {
        let url_ = this.baseUrl + "/api/services/app/SoBaoHanh/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<SoBaoHanhDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SoBaoHanhDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SoBaoHanhDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SoBaoHanhDto.fromJS(resultData200) : new SoBaoHanhDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SoBaoHanhDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SoBaoHanh/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    quanTam(input: QuanTamInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SoBaoHanh/QuanTam";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQuanTam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuanTam(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processQuanTam(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfSoBaoHanhDto> {
        let url_ = this.baseUrl + "/api/services/app/SoBaoHanh/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSoBaoHanhDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSoBaoHanhDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfSoBaoHanhDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSoBaoHanhDto.fromJS(resultData200) : new PagedResultDtoOfSoBaoHanhDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSoBaoHanhDto>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    authenticate(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class TramDichVuServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllNew(keyword: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetTramDichVuForView> {
        let url_ = this.baseUrl + "/api/services/app/TramDichVu/GetAllNew?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNew(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNew(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetTramDichVuForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetTramDichVuForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNew(response: HttpResponseBase): Observable<PagedResultDtoOfGetTramDichVuForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetTramDichVuForView.fromJS(resultData200) : new PagedResultDtoOfGetTramDichVuForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetTramDichVuForView>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateTramDichVuDto | null | undefined): Observable<TramDichVuDto> {
        let url_ = this.baseUrl + "/api/services/app/TramDichVu/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<TramDichVuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TramDichVuDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TramDichVuDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TramDichVuDto.fromJS(resultData200) : new TramDichVuDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TramDichVuDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: TramDichVuDto | null | undefined): Observable<TramDichVuDto> {
        let url_ = this.baseUrl + "/api/services/app/TramDichVu/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<TramDichVuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TramDichVuDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TramDichVuDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TramDichVuDto.fromJS(resultData200) : new TramDichVuDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TramDichVuDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TramDichVu/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<TramDichVuDto> {
        let url_ = this.baseUrl + "/api/services/app/TramDichVu/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TramDichVuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TramDichVuDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TramDichVuDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TramDichVuDto.fromJS(resultData200) : new TramDichVuDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TramDichVuDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfTramDichVuDto> {
        let url_ = this.baseUrl + "/api/services/app/TramDichVu/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTramDichVuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTramDichVuDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfTramDichVuDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTramDichVuDto.fromJS(resultData200) : new PagedResultDtoOfTramDichVuDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTramDichVuDto>(<any>null);
    }
}

@Injectable()
export class UploadServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    congViecImage(id: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Upload/CongViecImage?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCongViecImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCongViecImage(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCongViecImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    congViecHoanThanhImage(id: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Upload/CongViecHoanThanhImage?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCongViecHoanThanhImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCongViecHoanThanhImage(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCongViecHoanThanhImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    congViecKhachHangImage(id: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Upload/CongViecKhachHangImage?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCongViecKhachHangImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCongViecKhachHangImage(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCongViecKhachHangImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param tramDichVuId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllNew(keyword: string | null | undefined, isActive: boolean | null | undefined, tramDichVuId: number | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetUserForView> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAllNew?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (tramDichVuId !== undefined)
            url_ += "TramDichVuId=" + encodeURIComponent("" + tramDichVuId) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNew(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNew(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetUserForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetUserForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNew(response: HttpResponseBase): Observable<PagedResultDtoOfGetUserForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetUserForView.fromJS(resultData200) : new PagedResultDtoOfGetUserForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetUserForView>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateUserDto | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: UserDto | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<ListResultDtoOfRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleDto.fromJS(resultData200) : new ListResultDtoOfRoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetPassword(input: ResetPasswordDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param tramDichVuId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, tramDichVuId: number | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (tramDichVuId !== undefined)
            url_ += "TramDichVuId=" + encodeURIComponent("" + tramDichVuId) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserDto.fromJS(resultData200) : new PagedResultDtoOfUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserDto>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState | undefined;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState | undefined;
    tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
    phoneNumber: string;
    emailAddress: string | undefined;
    password: string;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.phoneNumber = data["phoneNumber"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        return data; 
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    phoneNumber: string;
    emailAddress: string | undefined;
    password: string;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean | undefined;
    message: string | undefined;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["message"] = this.message;
        return data; 
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean | undefined;
    message: string | undefined;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userName: string | undefined;
    emailAddress: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone(): ResetPasswordInput {
        const json = this.toJSON();
        let result = new ResetPasswordInput();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordInput {
    userName: string | undefined;
    emailAddress: string | undefined;
}

export class GetInfoDto implements IGetInfoDto {
    userName: string | undefined;
    name: string | undefined;
    birthday: moment.Moment | undefined;
    phoneNumber: string | undefined;
    emailAddress: string | undefined;
    address: string | undefined;
    districtId: number | undefined;
    provinceId: number | undefined;
    chuyenMon: string | undefined;
    phuTrach: string | undefined;
    tramDichVu: string | undefined;
    description: string | undefined;
    profilePicture: string | undefined;
    isCustomer: boolean | undefined;
    id: number | undefined;

    constructor(data?: IGetInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.birthday = data["birthday"] ? moment(data["birthday"].toString()) : <any>undefined;
            this.phoneNumber = data["phoneNumber"];
            this.emailAddress = data["emailAddress"];
            this.address = data["address"];
            this.districtId = data["districtId"];
            this.provinceId = data["provinceId"];
            this.chuyenMon = data["chuyenMon"];
            this.phuTrach = data["phuTrach"];
            this.tramDichVu = data["tramDichVu"];
            this.description = data["description"];
            this.profilePicture = data["profilePicture"];
            this.isCustomer = data["isCustomer"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber;
        data["emailAddress"] = this.emailAddress;
        data["address"] = this.address;
        data["districtId"] = this.districtId;
        data["provinceId"] = this.provinceId;
        data["chuyenMon"] = this.chuyenMon;
        data["phuTrach"] = this.phuTrach;
        data["tramDichVu"] = this.tramDichVu;
        data["description"] = this.description;
        data["profilePicture"] = this.profilePicture;
        data["isCustomer"] = this.isCustomer;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetInfoDto {
        const json = this.toJSON();
        let result = new GetInfoDto();
        result.init(json);
        return result;
    }
}

export interface IGetInfoDto {
    userName: string | undefined;
    name: string | undefined;
    birthday: moment.Moment | undefined;
    phoneNumber: string | undefined;
    emailAddress: string | undefined;
    address: string | undefined;
    districtId: number | undefined;
    provinceId: number | undefined;
    chuyenMon: string | undefined;
    phuTrach: string | undefined;
    tramDichVu: string | undefined;
    description: string | undefined;
    profilePicture: string | undefined;
    isCustomer: boolean | undefined;
    id: number | undefined;
}

export class UpdateInfoDto implements IUpdateInfoDto {
    profilePicture: string | undefined;
    name: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    birthday: moment.Moment | undefined;
    address: string | undefined;
    districtId: number | undefined;
    provinceId: number | undefined;
    description: string | undefined;

    constructor(data?: IUpdateInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePicture = data["profilePicture"];
            this.name = data["name"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.birthday = data["birthday"] ? moment(data["birthday"].toString()) : <any>undefined;
            this.address = data["address"];
            this.districtId = data["districtId"];
            this.provinceId = data["provinceId"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): UpdateInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        data["name"] = this.name;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["districtId"] = this.districtId;
        data["provinceId"] = this.provinceId;
        data["description"] = this.description;
        return data; 
    }

    clone(): UpdateInfoDto {
        const json = this.toJSON();
        let result = new UpdateInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateInfoDto {
    profilePicture: string | undefined;
    name: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    birthday: moment.Moment | undefined;
    address: string | undefined;
    districtId: number | undefined;
    provinceId: number | undefined;
    description: string | undefined;
}

export class SendActiveCodeInput implements ISendActiveCodeInput {
    userName: string | undefined;
    emailAddress: string | undefined;

    constructor(data?: ISendActiveCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendActiveCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendActiveCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone(): SendActiveCodeInput {
        const json = this.toJSON();
        let result = new SendActiveCodeInput();
        result.init(json);
        return result;
    }
}

export interface ISendActiveCodeInput {
    userName: string | undefined;
    emailAddress: string | undefined;
}

export class ActiveAccountInput implements IActiveAccountInput {
    userName: string | undefined;
    activeCode: string | undefined;

    constructor(data?: IActiveAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.activeCode = data["activeCode"];
        }
    }

    static fromJS(data: any): ActiveAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActiveAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["activeCode"] = this.activeCode;
        return data; 
    }

    clone(): ActiveAccountInput {
        const json = this.toJSON();
        let result = new ActiveAccountInput();
        result.init(json);
        return result;
    }
}

export interface IActiveAccountInput {
    userName: string | undefined;
    activeCode: string | undefined;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data; 
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class DanhSachCongViecInput implements IDanhSachCongViecInput {
    trangThaiIds: number[] | undefined;
    page: number | undefined;

    constructor(data?: IDanhSachCongViecInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["trangThaiIds"] && data["trangThaiIds"].constructor === Array) {
                this.trangThaiIds = [];
                for (let item of data["trangThaiIds"])
                    this.trangThaiIds.push(item);
            }
            this.page = data["page"];
        }
    }

    static fromJS(data: any): DanhSachCongViecInput {
        data = typeof data === 'object' ? data : {};
        let result = new DanhSachCongViecInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.trangThaiIds && this.trangThaiIds.constructor === Array) {
            data["trangThaiIds"] = [];
            for (let item of this.trangThaiIds)
                data["trangThaiIds"].push(item);
        }
        data["page"] = this.page;
        return data; 
    }

    clone(): DanhSachCongViecInput {
        const json = this.toJSON();
        let result = new DanhSachCongViecInput();
        result.init(json);
        return result;
    }
}

export interface IDanhSachCongViecInput {
    trangThaiIds: number[] | undefined;
    page: number | undefined;
}

export class CongViecDto implements ICongViecDto {
    tieuDe: string | undefined;
    noiDung: string | undefined;
    ghiChuKhachHang: string | undefined;
    ghiChuNhanVien: string | undefined;
    ghiChuQuanLy: string | undefined;
    linhKienThayThe: string | undefined;
    linhKienThanhTien: number | undefined;
    dichVuId: number | undefined;
    phuPhi: number | undefined;
    thanhTien: number | undefined;
    tramDichVuId: number | undefined;
    nhanVienId: number | undefined;
    khachHangId: number | undefined;
    khachHangName: string | undefined;
    ngayGioHen: moment.Moment | undefined;
    soDienThoai: string | undefined;
    diaChi: string | undefined;
    diaChiQuanHuyenId: number | undefined;
    diaChiTinhThanhId: number | undefined;
    location: string | undefined;
    lyDoHuy: string | undefined;
    trangThaiId: number | undefined;
    loaiCongViecId: number | undefined;
    image1: string | undefined;
    image2: string | undefined;
    image3: string | undefined;
    imageHoanThanh1: string | undefined;
    imageHoanThanh2: string | undefined;
    imageHoanThanh3: string | undefined;
    imageKhachHang1: string | undefined;
    imageKhachHang2: string | undefined;
    imageKhachHang3: string | undefined;
    sanPhamName: string | undefined;
    sanPhamModel: string | undefined;
    sanPhamSerial: string | undefined;
    soGiaoNhan: string | undefined;
    ngayYeuCau: moment.Moment | undefined;
    ngayKhamBenh: moment.Moment | undefined;
    ngayGiaoLinhKien: moment.Moment | undefined;
    ngayHoanThanh: moment.Moment | undefined;
    ngayDanhGia: moment.Moment | undefined;
    ngayDongCa: moment.Moment | undefined;
    danhGiaDiem: number | undefined;
    danhGiaText: string | undefined;
    nhomDichVuId: number | undefined;
    nhomDichVuName: string | undefined;
    dichVuName: string | undefined;
    tramDichVuName: string | undefined;
    nhanVienName: string | undefined;
    nhanVienPhone: string | undefined;
    trangThaiName: string | undefined;
    danhSachHangMuc: CongViecHangMucDto[] | undefined;
    id: number | undefined;

    constructor(data?: ICongViecDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tieuDe = data["tieuDe"];
            this.noiDung = data["noiDung"];
            this.ghiChuKhachHang = data["ghiChuKhachHang"];
            this.ghiChuNhanVien = data["ghiChuNhanVien"];
            this.ghiChuQuanLy = data["ghiChuQuanLy"];
            this.linhKienThayThe = data["linhKienThayThe"];
            this.linhKienThanhTien = data["linhKienThanhTien"];
            this.dichVuId = data["dichVuId"];
            this.phuPhi = data["phuPhi"];
            this.thanhTien = data["thanhTien"];
            this.tramDichVuId = data["tramDichVuId"];
            this.nhanVienId = data["nhanVienId"];
            this.khachHangId = data["khachHangId"];
            this.khachHangName = data["khachHangName"];
            this.ngayGioHen = data["ngayGioHen"] ? moment(data["ngayGioHen"].toString()) : <any>undefined;
            this.soDienThoai = data["soDienThoai"];
            this.diaChi = data["diaChi"];
            this.diaChiQuanHuyenId = data["diaChiQuanHuyenId"];
            this.diaChiTinhThanhId = data["diaChiTinhThanhId"];
            this.location = data["location"];
            this.lyDoHuy = data["lyDoHuy"];
            this.trangThaiId = data["trangThaiId"];
            this.loaiCongViecId = data["loaiCongViecId"];
            this.image1 = data["image1"];
            this.image2 = data["image2"];
            this.image3 = data["image3"];
            this.imageHoanThanh1 = data["imageHoanThanh1"];
            this.imageHoanThanh2 = data["imageHoanThanh2"];
            this.imageHoanThanh3 = data["imageHoanThanh3"];
            this.imageKhachHang1 = data["imageKhachHang1"];
            this.imageKhachHang2 = data["imageKhachHang2"];
            this.imageKhachHang3 = data["imageKhachHang3"];
            this.sanPhamName = data["sanPhamName"];
            this.sanPhamModel = data["sanPhamModel"];
            this.sanPhamSerial = data["sanPhamSerial"];
            this.soGiaoNhan = data["soGiaoNhan"];
            this.ngayYeuCau = data["ngayYeuCau"] ? moment(data["ngayYeuCau"].toString()) : <any>undefined;
            this.ngayKhamBenh = data["ngayKhamBenh"] ? moment(data["ngayKhamBenh"].toString()) : <any>undefined;
            this.ngayGiaoLinhKien = data["ngayGiaoLinhKien"] ? moment(data["ngayGiaoLinhKien"].toString()) : <any>undefined;
            this.ngayHoanThanh = data["ngayHoanThanh"] ? moment(data["ngayHoanThanh"].toString()) : <any>undefined;
            this.ngayDanhGia = data["ngayDanhGia"] ? moment(data["ngayDanhGia"].toString()) : <any>undefined;
            this.ngayDongCa = data["ngayDongCa"] ? moment(data["ngayDongCa"].toString()) : <any>undefined;
            this.danhGiaDiem = data["danhGiaDiem"];
            this.danhGiaText = data["danhGiaText"];
            this.nhomDichVuId = data["nhomDichVuId"];
            this.nhomDichVuName = data["nhomDichVuName"];
            this.dichVuName = data["dichVuName"];
            this.tramDichVuName = data["tramDichVuName"];
            this.nhanVienName = data["nhanVienName"];
            this.nhanVienPhone = data["nhanVienPhone"];
            this.trangThaiName = data["trangThaiName"];
            if (data["danhSachHangMuc"] && data["danhSachHangMuc"].constructor === Array) {
                this.danhSachHangMuc = [];
                for (let item of data["danhSachHangMuc"])
                    this.danhSachHangMuc.push(CongViecHangMucDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CongViecDto {
        data = typeof data === 'object' ? data : {};
        let result = new CongViecDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tieuDe"] = this.tieuDe;
        data["noiDung"] = this.noiDung;
        data["ghiChuKhachHang"] = this.ghiChuKhachHang;
        data["ghiChuNhanVien"] = this.ghiChuNhanVien;
        data["ghiChuQuanLy"] = this.ghiChuQuanLy;
        data["linhKienThayThe"] = this.linhKienThayThe;
        data["linhKienThanhTien"] = this.linhKienThanhTien;
        data["dichVuId"] = this.dichVuId;
        data["phuPhi"] = this.phuPhi;
        data["thanhTien"] = this.thanhTien;
        data["tramDichVuId"] = this.tramDichVuId;
        data["nhanVienId"] = this.nhanVienId;
        data["khachHangId"] = this.khachHangId;
        data["khachHangName"] = this.khachHangName;
        data["ngayGioHen"] = this.ngayGioHen ? this.ngayGioHen.toISOString() : <any>undefined;
        data["soDienThoai"] = this.soDienThoai;
        data["diaChi"] = this.diaChi;
        data["diaChiQuanHuyenId"] = this.diaChiQuanHuyenId;
        data["diaChiTinhThanhId"] = this.diaChiTinhThanhId;
        data["location"] = this.location;
        data["lyDoHuy"] = this.lyDoHuy;
        data["trangThaiId"] = this.trangThaiId;
        data["loaiCongViecId"] = this.loaiCongViecId;
        data["image1"] = this.image1;
        data["image2"] = this.image2;
        data["image3"] = this.image3;
        data["imageHoanThanh1"] = this.imageHoanThanh1;
        data["imageHoanThanh2"] = this.imageHoanThanh2;
        data["imageHoanThanh3"] = this.imageHoanThanh3;
        data["imageKhachHang1"] = this.imageKhachHang1;
        data["imageKhachHang2"] = this.imageKhachHang2;
        data["imageKhachHang3"] = this.imageKhachHang3;
        data["sanPhamName"] = this.sanPhamName;
        data["sanPhamModel"] = this.sanPhamModel;
        data["sanPhamSerial"] = this.sanPhamSerial;
        data["soGiaoNhan"] = this.soGiaoNhan;
        data["ngayYeuCau"] = this.ngayYeuCau ? this.ngayYeuCau.toISOString() : <any>undefined;
        data["ngayKhamBenh"] = this.ngayKhamBenh ? this.ngayKhamBenh.toISOString() : <any>undefined;
        data["ngayGiaoLinhKien"] = this.ngayGiaoLinhKien ? this.ngayGiaoLinhKien.toISOString() : <any>undefined;
        data["ngayHoanThanh"] = this.ngayHoanThanh ? this.ngayHoanThanh.toISOString() : <any>undefined;
        data["ngayDanhGia"] = this.ngayDanhGia ? this.ngayDanhGia.toISOString() : <any>undefined;
        data["ngayDongCa"] = this.ngayDongCa ? this.ngayDongCa.toISOString() : <any>undefined;
        data["danhGiaDiem"] = this.danhGiaDiem;
        data["danhGiaText"] = this.danhGiaText;
        data["nhomDichVuId"] = this.nhomDichVuId;
        data["nhomDichVuName"] = this.nhomDichVuName;
        data["dichVuName"] = this.dichVuName;
        data["tramDichVuName"] = this.tramDichVuName;
        data["nhanVienName"] = this.nhanVienName;
        data["nhanVienPhone"] = this.nhanVienPhone;
        data["trangThaiName"] = this.trangThaiName;
        if (this.danhSachHangMuc && this.danhSachHangMuc.constructor === Array) {
            data["danhSachHangMuc"] = [];
            for (let item of this.danhSachHangMuc)
                data["danhSachHangMuc"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CongViecDto {
        const json = this.toJSON();
        let result = new CongViecDto();
        result.init(json);
        return result;
    }
}

export interface ICongViecDto {
    tieuDe: string | undefined;
    noiDung: string | undefined;
    ghiChuKhachHang: string | undefined;
    ghiChuNhanVien: string | undefined;
    ghiChuQuanLy: string | undefined;
    linhKienThayThe: string | undefined;
    linhKienThanhTien: number | undefined;
    dichVuId: number | undefined;
    phuPhi: number | undefined;
    thanhTien: number | undefined;
    tramDichVuId: number | undefined;
    nhanVienId: number | undefined;
    khachHangId: number | undefined;
    khachHangName: string | undefined;
    ngayGioHen: moment.Moment | undefined;
    soDienThoai: string | undefined;
    diaChi: string | undefined;
    diaChiQuanHuyenId: number | undefined;
    diaChiTinhThanhId: number | undefined;
    location: string | undefined;
    lyDoHuy: string | undefined;
    trangThaiId: number | undefined;
    loaiCongViecId: number | undefined;
    image1: string | undefined;
    image2: string | undefined;
    image3: string | undefined;
    imageHoanThanh1: string | undefined;
    imageHoanThanh2: string | undefined;
    imageHoanThanh3: string | undefined;
    imageKhachHang1: string | undefined;
    imageKhachHang2: string | undefined;
    imageKhachHang3: string | undefined;
    sanPhamName: string | undefined;
    sanPhamModel: string | undefined;
    sanPhamSerial: string | undefined;
    soGiaoNhan: string | undefined;
    ngayYeuCau: moment.Moment | undefined;
    ngayKhamBenh: moment.Moment | undefined;
    ngayGiaoLinhKien: moment.Moment | undefined;
    ngayHoanThanh: moment.Moment | undefined;
    ngayDanhGia: moment.Moment | undefined;
    ngayDongCa: moment.Moment | undefined;
    danhGiaDiem: number | undefined;
    danhGiaText: string | undefined;
    nhomDichVuId: number | undefined;
    nhomDichVuName: string | undefined;
    dichVuName: string | undefined;
    tramDichVuName: string | undefined;
    nhanVienName: string | undefined;
    nhanVienPhone: string | undefined;
    trangThaiName: string | undefined;
    danhSachHangMuc: CongViecHangMucDto[] | undefined;
    id: number | undefined;
}

export class CongViecHangMucDto implements ICongViecHangMucDto {
    hangMucId: number | undefined;
    name: string | undefined;
    donViTinh: string | undefined;
    soLuong: number | undefined;
    donGia: number | undefined;
    thanhTien: number | undefined;

    constructor(data?: ICongViecHangMucDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.hangMucId = data["hangMucId"];
            this.name = data["name"];
            this.donViTinh = data["donViTinh"];
            this.soLuong = data["soLuong"];
            this.donGia = data["donGia"];
            this.thanhTien = data["thanhTien"];
        }
    }

    static fromJS(data: any): CongViecHangMucDto {
        data = typeof data === 'object' ? data : {};
        let result = new CongViecHangMucDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hangMucId"] = this.hangMucId;
        data["name"] = this.name;
        data["donViTinh"] = this.donViTinh;
        data["soLuong"] = this.soLuong;
        data["donGia"] = this.donGia;
        data["thanhTien"] = this.thanhTien;
        return data; 
    }

    clone(): CongViecHangMucDto {
        const json = this.toJSON();
        let result = new CongViecHangMucDto();
        result.init(json);
        return result;
    }
}

export interface ICongViecHangMucDto {
    hangMucId: number | undefined;
    name: string | undefined;
    donViTinh: string | undefined;
    soLuong: number | undefined;
    donGia: number | undefined;
    thanhTien: number | undefined;
}

export class GetTotalOutput implements IGetTotalOutput {
    choNhanViec: number | undefined;
    dangXuLy: number | undefined;
    daHoanThanh: number | undefined;

    constructor(data?: IGetTotalOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.choNhanViec = data["choNhanViec"];
            this.dangXuLy = data["dangXuLy"];
            this.daHoanThanh = data["daHoanThanh"];
        }
    }

    static fromJS(data: any): GetTotalOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTotalOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["choNhanViec"] = this.choNhanViec;
        data["dangXuLy"] = this.dangXuLy;
        data["daHoanThanh"] = this.daHoanThanh;
        return data; 
    }

    clone(): GetTotalOutput {
        const json = this.toJSON();
        let result = new GetTotalOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTotalOutput {
    choNhanViec: number | undefined;
    dangXuLy: number | undefined;
    daHoanThanh: number | undefined;
}

export class CreateYeuCauDto implements ICreateYeuCauDto {
    tieuDe: string | undefined;
    noiDung: string | undefined;
    dichVuId: number | undefined;
    ngayGioHen: moment.Moment | undefined;
    soDienThoai: string | undefined;
    diaChi: string | undefined;
    diaChiQuanHuyenId: number | undefined;
    diaChiTinhThanhId: number | undefined;

    constructor(data?: ICreateYeuCauDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tieuDe = data["tieuDe"];
            this.noiDung = data["noiDung"];
            this.dichVuId = data["dichVuId"];
            this.ngayGioHen = data["ngayGioHen"] ? moment(data["ngayGioHen"].toString()) : <any>undefined;
            this.soDienThoai = data["soDienThoai"];
            this.diaChi = data["diaChi"];
            this.diaChiQuanHuyenId = data["diaChiQuanHuyenId"];
            this.diaChiTinhThanhId = data["diaChiTinhThanhId"];
        }
    }

    static fromJS(data: any): CreateYeuCauDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateYeuCauDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tieuDe"] = this.tieuDe;
        data["noiDung"] = this.noiDung;
        data["dichVuId"] = this.dichVuId;
        data["ngayGioHen"] = this.ngayGioHen ? this.ngayGioHen.toISOString() : <any>undefined;
        data["soDienThoai"] = this.soDienThoai;
        data["diaChi"] = this.diaChi;
        data["diaChiQuanHuyenId"] = this.diaChiQuanHuyenId;
        data["diaChiTinhThanhId"] = this.diaChiTinhThanhId;
        return data; 
    }

    clone(): CreateYeuCauDto {
        const json = this.toJSON();
        let result = new CreateYeuCauDto();
        result.init(json);
        return result;
    }
}

export interface ICreateYeuCauDto {
    tieuDe: string | undefined;
    noiDung: string | undefined;
    dichVuId: number | undefined;
    ngayGioHen: moment.Moment | undefined;
    soDienThoai: string | undefined;
    diaChi: string | undefined;
    diaChiQuanHuyenId: number | undefined;
    diaChiTinhThanhId: number | undefined;
}

export class NhanViecInput implements INhanViecInput {
    id: number | undefined;
    dongY: boolean | undefined;
    lyDo: string | undefined;

    constructor(data?: INhanViecInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.dongY = data["dongY"];
            this.lyDo = data["lyDo"];
        }
    }

    static fromJS(data: any): NhanViecInput {
        data = typeof data === 'object' ? data : {};
        let result = new NhanViecInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dongY"] = this.dongY;
        data["lyDo"] = this.lyDo;
        return data; 
    }

    clone(): NhanViecInput {
        const json = this.toJSON();
        let result = new NhanViecInput();
        result.init(json);
        return result;
    }
}

export interface INhanViecInput {
    id: number | undefined;
    dongY: boolean | undefined;
    lyDo: string | undefined;
}

export class CapNhatLocationInput implements ICapNhatLocationInput {
    id: number | undefined;
    lat: string | undefined;
    lon: string | undefined;

    constructor(data?: ICapNhatLocationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.lat = data["lat"];
            this.lon = data["lon"];
        }
    }

    static fromJS(data: any): CapNhatLocationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CapNhatLocationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lat"] = this.lat;
        data["lon"] = this.lon;
        return data; 
    }

    clone(): CapNhatLocationInput {
        const json = this.toJSON();
        let result = new CapNhatLocationInput();
        result.init(json);
        return result;
    }
}

export interface ICapNhatLocationInput {
    id: number | undefined;
    lat: string | undefined;
    lon: string | undefined;
}

export class TraVeTramTruongInput implements ITraVeTramTruongInput {
    id: number | undefined;
    lyDo: string | undefined;

    constructor(data?: ITraVeTramTruongInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.lyDo = data["lyDo"];
        }
    }

    static fromJS(data: any): TraVeTramTruongInput {
        data = typeof data === 'object' ? data : {};
        let result = new TraVeTramTruongInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lyDo"] = this.lyDo;
        return data; 
    }

    clone(): TraVeTramTruongInput {
        const json = this.toJSON();
        let result = new TraVeTramTruongInput();
        result.init(json);
        return result;
    }
}

export interface ITraVeTramTruongInput {
    id: number | undefined;
    lyDo: string | undefined;
}

export class PhanLoaiCongViecInput implements IPhanLoaiCongViecInput {
    loaiCongViecId: number | undefined;
    dichVuId: number | undefined;
    ghiChuNhanVien: string | undefined;
    id: number | undefined;

    constructor(data?: IPhanLoaiCongViecInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.loaiCongViecId = data["loaiCongViecId"];
            this.dichVuId = data["dichVuId"];
            this.ghiChuNhanVien = data["ghiChuNhanVien"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PhanLoaiCongViecInput {
        data = typeof data === 'object' ? data : {};
        let result = new PhanLoaiCongViecInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loaiCongViecId"] = this.loaiCongViecId;
        data["dichVuId"] = this.dichVuId;
        data["ghiChuNhanVien"] = this.ghiChuNhanVien;
        data["id"] = this.id;
        return data; 
    }

    clone(): PhanLoaiCongViecInput {
        const json = this.toJSON();
        let result = new PhanLoaiCongViecInput();
        result.init(json);
        return result;
    }
}

export interface IPhanLoaiCongViecInput {
    loaiCongViecId: number | undefined;
    dichVuId: number | undefined;
    ghiChuNhanVien: string | undefined;
    id: number | undefined;
}

export class BaoGiaCongViecInput implements IBaoGiaCongViecInput {
    phuPhi: number | undefined;
    linhKienThayThe: string | undefined;
    linhKienThanhTien: number | undefined;
    yeuCauLinhKien: number | undefined;
    danhSachHangMuc: DanhSachHangMucDto[] | undefined;
    id: number | undefined;

    constructor(data?: IBaoGiaCongViecInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.phuPhi = data["phuPhi"];
            this.linhKienThayThe = data["linhKienThayThe"];
            this.linhKienThanhTien = data["linhKienThanhTien"];
            this.yeuCauLinhKien = data["yeuCauLinhKien"];
            if (data["danhSachHangMuc"] && data["danhSachHangMuc"].constructor === Array) {
                this.danhSachHangMuc = [];
                for (let item of data["danhSachHangMuc"])
                    this.danhSachHangMuc.push(DanhSachHangMucDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BaoGiaCongViecInput {
        data = typeof data === 'object' ? data : {};
        let result = new BaoGiaCongViecInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phuPhi"] = this.phuPhi;
        data["linhKienThayThe"] = this.linhKienThayThe;
        data["linhKienThanhTien"] = this.linhKienThanhTien;
        data["yeuCauLinhKien"] = this.yeuCauLinhKien;
        if (this.danhSachHangMuc && this.danhSachHangMuc.constructor === Array) {
            data["danhSachHangMuc"] = [];
            for (let item of this.danhSachHangMuc)
                data["danhSachHangMuc"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): BaoGiaCongViecInput {
        const json = this.toJSON();
        let result = new BaoGiaCongViecInput();
        result.init(json);
        return result;
    }
}

export interface IBaoGiaCongViecInput {
    phuPhi: number | undefined;
    linhKienThayThe: string | undefined;
    linhKienThanhTien: number | undefined;
    yeuCauLinhKien: number | undefined;
    danhSachHangMuc: DanhSachHangMucDto[] | undefined;
    id: number | undefined;
}

export class DanhSachHangMucDto implements IDanhSachHangMucDto {
    hangMucId: number | undefined;
    soLuong: number | undefined;
    donGia: number | undefined;

    constructor(data?: IDanhSachHangMucDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.hangMucId = data["hangMucId"];
            this.soLuong = data["soLuong"];
            this.donGia = data["donGia"];
        }
    }

    static fromJS(data: any): DanhSachHangMucDto {
        data = typeof data === 'object' ? data : {};
        let result = new DanhSachHangMucDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hangMucId"] = this.hangMucId;
        data["soLuong"] = this.soLuong;
        data["donGia"] = this.donGia;
        return data; 
    }

    clone(): DanhSachHangMucDto {
        const json = this.toJSON();
        let result = new DanhSachHangMucDto();
        result.init(json);
        return result;
    }
}

export interface IDanhSachHangMucDto {
    hangMucId: number | undefined;
    soLuong: number | undefined;
    donGia: number | undefined;
}

export class HoanThanhCongViecInput implements IHoanThanhCongViecInput {
    ghiChuNhanVien: string | undefined;
    id: number | undefined;

    constructor(data?: IHoanThanhCongViecInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ghiChuNhanVien = data["ghiChuNhanVien"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): HoanThanhCongViecInput {
        data = typeof data === 'object' ? data : {};
        let result = new HoanThanhCongViecInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ghiChuNhanVien"] = this.ghiChuNhanVien;
        data["id"] = this.id;
        return data; 
    }

    clone(): HoanThanhCongViecInput {
        const json = this.toJSON();
        let result = new HoanThanhCongViecInput();
        result.init(json);
        return result;
    }
}

export interface IHoanThanhCongViecInput {
    ghiChuNhanVien: string | undefined;
    id: number | undefined;
}

export class KhachHangHuyInput implements IKhachHangHuyInput {
    id: number | undefined;
    lyDo: string | undefined;

    constructor(data?: IKhachHangHuyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.lyDo = data["lyDo"];
        }
    }

    static fromJS(data: any): KhachHangHuyInput {
        data = typeof data === 'object' ? data : {};
        let result = new KhachHangHuyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lyDo"] = this.lyDo;
        return data; 
    }

    clone(): KhachHangHuyInput {
        const json = this.toJSON();
        let result = new KhachHangHuyInput();
        result.init(json);
        return result;
    }
}

export interface IKhachHangHuyInput {
    id: number | undefined;
    lyDo: string | undefined;
}

export class KhachHangDanhGiaInput implements IKhachHangDanhGiaInput {
    id: number | undefined;
    danhGiaDiem: number | undefined;
    danhGiaText: string | undefined;

    constructor(data?: IKhachHangDanhGiaInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.danhGiaDiem = data["danhGiaDiem"];
            this.danhGiaText = data["danhGiaText"];
        }
    }

    static fromJS(data: any): KhachHangDanhGiaInput {
        data = typeof data === 'object' ? data : {};
        let result = new KhachHangDanhGiaInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["danhGiaDiem"] = this.danhGiaDiem;
        data["danhGiaText"] = this.danhGiaText;
        return data; 
    }

    clone(): KhachHangDanhGiaInput {
        const json = this.toJSON();
        let result = new KhachHangDanhGiaInput();
        result.init(json);
        return result;
    }
}

export interface IKhachHangDanhGiaInput {
    id: number | undefined;
    danhGiaDiem: number | undefined;
    danhGiaText: string | undefined;
}
export interface IThongTinDinhKemThamDinhDto {
    fileSize: number | undefined;
    fileURL: string | undefined;
    fileName: string | undefined;
    id: number | undefined;
}

export class ThongTinDinhKemThamDinhDto implements IThongTinDinhKemThamDinhDto {
    fileSize: number | undefined;
    fileURL: string | undefined;
    fileName: string | undefined;
    id: number | undefined;

    constructor(data?: IThongTinDinhKemThamDinhDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileSize = data["fileSize"];
            this.fileURL = data["fileURL"];
            this.fileName = data["fileName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ThongTinDinhKemThamDinhDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongTinDinhKemThamDinhDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileSize"] = this.fileSize;
        data["fileURL"] = this.fileURL;
        data["fileName"] = this.fileName;
        data["id"] = this.id;
        return data; 
    }
}

export class DuplicateThongTinSampleOutput implements IDuplicateThongTinSampleOutput {
    total: number | undefined;
    listFileNameDuplicate: string[] | undefined;

    constructor(data?: IDuplicateThongTinSampleOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"];
            if (data["listFileNameDuplicate"] && data["listFileNameDuplicate"].constructor === Array) {
                this.listFileNameDuplicate = [];
                for (let item of data["listFileNameDuplicate"])
                    this.listFileNameDuplicate.push(item);
            }
        }
    }

    static fromJS(data: any): DuplicateThongTinSampleOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateThongTinSampleOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (this.listFileNameDuplicate && this.listFileNameDuplicate.constructor === Array) {
            data["listFileNameDuplicate"] = [];
            for (let item of this.listFileNameDuplicate)
                data["listFileNameDuplicate"].push(item);
        }
        return data; 
    }

    clone(): DuplicateThongTinSampleOutput {
        const json = this.toJSON();
        let result = new DuplicateThongTinSampleOutput();
        result.init(json);
        return result;
    }
}

export interface IThongTinDinhKemKetQuaCongViecDto {
    fileSize: number | undefined;
    fileURL: string | undefined;
    fileName: string | undefined;
    id: number | undefined;
}

export class ThongTinDinhKemKetQuaCongViecDto implements IThongTinDinhKemKetQuaCongViecDto {
    fileSize: number | undefined;
    fileURL: string | undefined;
    fileName: string | undefined;
    id: number | undefined;

    constructor(data?: IThongTinDinhKemKetQuaCongViecDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileSize = data["fileSize"];
            this.fileURL = data["fileURL"];
            this.fileName = data["fileName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ThongTinDinhKemKetQuaCongViecDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongTinDinhKemKetQuaCongViecDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileSize"] = this.fileSize;
        data["fileURL"] = this.fileURL;
        data["fileName"] = this.fileName;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDuplicateThongTinSampleOutput {
    total: number | undefined;
    listFileNameDuplicate: string[] | undefined;
}

export class PagedResultDtoOfDanhMucDichVuDto implements IPagedResultDtoOfDanhMucDichVuDto {
    totalCount: number | undefined;
    items: DanhMucDichVuDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDanhMucDichVuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DanhMucDichVuDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDanhMucDichVuDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDanhMucDichVuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDanhMucDichVuDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDanhMucDichVuDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDanhMucDichVuDto {
    totalCount: number | undefined;
    items: DanhMucDichVuDto[] | undefined;
}

export class DanhMucDichVuDto implements IDanhMucDichVuDto {
    name: string | undefined;
    description: string | undefined;
    nhomDichVuId: number | undefined;
    isActive: boolean | undefined;
    nhomDichVuName: string | undefined;
    id: number | undefined;

    constructor(data?: IDanhMucDichVuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.nhomDichVuId = data["nhomDichVuId"];
            this.isActive = data["isActive"];
            this.nhomDichVuName = data["nhomDichVuName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DanhMucDichVuDto {
        data = typeof data === 'object' ? data : {};
        let result = new DanhMucDichVuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["nhomDichVuId"] = this.nhomDichVuId;
        data["isActive"] = this.isActive;
        data["nhomDichVuName"] = this.nhomDichVuName;
        data["id"] = this.id;
        return data; 
    }

    clone(): DanhMucDichVuDto {
        const json = this.toJSON();
        let result = new DanhMucDichVuDto();
        result.init(json);
        return result;
    }
}

export interface IDanhMucDichVuDto {
    name: string | undefined;
    description: string | undefined;
    nhomDichVuId: number | undefined;
    isActive: boolean | undefined;
    nhomDichVuName: string | undefined;
    id: number | undefined;
}

export class CreateDanhMucDichVuDto implements ICreateDanhMucDichVuDto {
    name: string | undefined;
    description: string | undefined;
    nhomDichVuId: number | undefined;
    isActive: boolean | undefined;

    constructor(data?: ICreateDanhMucDichVuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.nhomDichVuId = data["nhomDichVuId"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): CreateDanhMucDichVuDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDanhMucDichVuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["nhomDichVuId"] = this.nhomDichVuId;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateDanhMucDichVuDto {
        const json = this.toJSON();
        let result = new CreateDanhMucDichVuDto();
        result.init(json);
        return result;
    }
}

export interface ICreateDanhMucDichVuDto {
    name: string | undefined;
    description: string | undefined;
    nhomDichVuId: number | undefined;
    isActive: boolean | undefined;
}

export class DanhMucHangDto implements IDanhMucHangDto {
    name: string | undefined;
    description: string | undefined;
    id: number | undefined;

    constructor(data?: IDanhMucHangDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DanhMucHangDto {
        data = typeof data === 'object' ? data : {};
        let result = new DanhMucHangDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): DanhMucHangDto {
        const json = this.toJSON();
        let result = new DanhMucHangDto();
        result.init(json);
        return result;
    }
}

export interface IDanhMucHangDto {
    name: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDanhMucHangDto implements IPagedResultDtoOfDanhMucHangDto {
    totalCount: number | undefined;
    items: DanhMucHangDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDanhMucHangDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DanhMucHangDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDanhMucHangDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDanhMucHangDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDanhMucHangDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDanhMucHangDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDanhMucHangDto {
    totalCount: number | undefined;
    items: DanhMucHangDto[] | undefined;
}

export class CreateDanhMucHangDto implements ICreateDanhMucHangDto {
    name: string | undefined;
    description: string | undefined;

    constructor(data?: ICreateDanhMucHangDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): CreateDanhMucHangDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDanhMucHangDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }

    clone(): CreateDanhMucHangDto {
        const json = this.toJSON();
        let result = new CreateDanhMucHangDto();
        result.init(json);
        return result;
    }
}

export interface ICreateDanhMucHangDto {
    name: string | undefined;
    description: string | undefined;
}

export class PagedResultDtoOfDanhMucHangMucDto implements IPagedResultDtoOfDanhMucHangMucDto {
    totalCount: number | undefined;
    items: DanhMucHangMucDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDanhMucHangMucDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DanhMucHangMucDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDanhMucHangMucDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDanhMucHangMucDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDanhMucHangMucDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDanhMucHangMucDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDanhMucHangMucDto {
    totalCount: number | undefined;
    items: DanhMucHangMucDto[] | undefined;
}

export class DanhMucHangMucDto implements IDanhMucHangMucDto {
    name: string | undefined;
    dichVuId: number | undefined;
    donViTinh: string | undefined;
    donGia: number | undefined;
    description: string | undefined;
    isActive: boolean | undefined;
    dichVuName: string | undefined;
    nhomDichVuName: string | undefined;
    nhomDichVuId: number | undefined;
    id: number | undefined;

    constructor(data?: IDanhMucHangMucDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.dichVuId = data["dichVuId"];
            this.donViTinh = data["donViTinh"];
            this.donGia = data["donGia"];
            this.description = data["description"];
            this.isActive = data["isActive"];
            this.dichVuName = data["dichVuName"];
            this.nhomDichVuName = data["nhomDichVuName"];
            this.nhomDichVuId = data["nhomDichVuId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DanhMucHangMucDto {
        data = typeof data === 'object' ? data : {};
        let result = new DanhMucHangMucDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["dichVuId"] = this.dichVuId;
        data["donViTinh"] = this.donViTinh;
        data["donGia"] = this.donGia;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["dichVuName"] = this.dichVuName;
        data["nhomDichVuName"] = this.nhomDichVuName;
        data["nhomDichVuId"] = this.nhomDichVuId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DanhMucHangMucDto {
        const json = this.toJSON();
        let result = new DanhMucHangMucDto();
        result.init(json);
        return result;
    }
}

export interface IDanhMucHangMucDto {
    name: string | undefined;
    dichVuId: number | undefined;
    donViTinh: string | undefined;
    donGia: number | undefined;
    description: string | undefined;
    isActive: boolean | undefined;
    dichVuName: string | undefined;
    nhomDichVuName: string | undefined;
    nhomDichVuId: number | undefined;
    id: number | undefined;
}

export class CreateDanhMucHangMucDto implements ICreateDanhMucHangMucDto {
    name: string | undefined;
    dichVuId: number | undefined;
    donViTinh: string | undefined;
    donGia: number | undefined;
    description: string | undefined;
    isActive: boolean | undefined;

    constructor(data?: ICreateDanhMucHangMucDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.dichVuId = data["dichVuId"];
            this.donViTinh = data["donViTinh"];
            this.donGia = data["donGia"];
            this.description = data["description"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): CreateDanhMucHangMucDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDanhMucHangMucDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["dichVuId"] = this.dichVuId;
        data["donViTinh"] = this.donViTinh;
        data["donGia"] = this.donGia;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateDanhMucHangMucDto {
        const json = this.toJSON();
        let result = new CreateDanhMucHangMucDto();
        result.init(json);
        return result;
    }
}

export interface ICreateDanhMucHangMucDto {
    name: string | undefined;
    dichVuId: number | undefined;
    donViTinh: string | undefined;
    donGia: number | undefined;
    description: string | undefined;
    isActive: boolean | undefined;
}

export class DanhMucNhomDichVuDto implements IDanhMucNhomDichVuDto {
    name: string | undefined;
    description: string | undefined;
    id: number | undefined;

    constructor(data?: IDanhMucNhomDichVuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DanhMucNhomDichVuDto {
        data = typeof data === 'object' ? data : {};
        let result = new DanhMucNhomDichVuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): DanhMucNhomDichVuDto {
        const json = this.toJSON();
        let result = new DanhMucNhomDichVuDto();
        result.init(json);
        return result;
    }
}

export interface IDanhMucNhomDichVuDto {
    name: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDanhMucNhomDichVuDto implements IPagedResultDtoOfDanhMucNhomDichVuDto {
    totalCount: number | undefined;
    items: DanhMucNhomDichVuDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDanhMucNhomDichVuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DanhMucNhomDichVuDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDanhMucNhomDichVuDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDanhMucNhomDichVuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDanhMucNhomDichVuDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDanhMucNhomDichVuDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDanhMucNhomDichVuDto {
    totalCount: number | undefined;
    items: DanhMucNhomDichVuDto[] | undefined;
}

export class CreateDanhMucNhomDichVuDto implements ICreateDanhMucNhomDichVuDto {
    name: string | undefined;
    description: string | undefined;

    constructor(data?: ICreateDanhMucNhomDichVuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): CreateDanhMucNhomDichVuDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDanhMucNhomDichVuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }

    clone(): CreateDanhMucNhomDichVuDto {
        const json = this.toJSON();
        let result = new CreateDanhMucNhomDichVuDto();
        result.init(json);
        return result;
    }
}

export interface ICreateDanhMucNhomDichVuDto {
    name: string | undefined;
    description: string | undefined;
}

export class CreateDieuKhoanSuDungDto implements ICreateDieuKhoanSuDungDto {
    noiDung: string | undefined;

    constructor(data?: ICreateDieuKhoanSuDungDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.noiDung = data["noiDung"];
        }
    }

    static fromJS(data: any): CreateDieuKhoanSuDungDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDieuKhoanSuDungDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noiDung"] = this.noiDung;
        return data; 
    }

    clone(): CreateDieuKhoanSuDungDto {
        const json = this.toJSON();
        let result = new CreateDieuKhoanSuDungDto();
        result.init(json);
        return result;
    }
}

export interface ICreateDieuKhoanSuDungDto {
    noiDung: string | undefined;
}

export class ThongTinHeThongDto implements IThongTinHeThongDto {
    soHotLine: string | undefined;
    email: string | undefined;
    facebook: string | undefined;
    diaChi: string | undefined;
    location: string | undefined;

    constructor(data?: IThongTinHeThongDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.soHotLine = data["soHotLine"];
            this.email = data["email"];
            this.facebook = data["facebook"];
            this.diaChi = data["diaChi"];
            this.location = data["location"];
        }
    }

    static fromJS(data: any): ThongTinHeThongDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongTinHeThongDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["soHotLine"] = this.soHotLine;
        data["email"] = this.email;
        data["facebook"] = this.facebook;
        data["diaChi"] = this.diaChi;
        data["location"] = this.location;
        return data; 
    }

    clone(): ThongTinHeThongDto {
        const json = this.toJSON();
        let result = new ThongTinHeThongDto();
        result.init(json);
        return result;
    }
}

export interface IThongTinHeThongDto {
    soHotLine: string | undefined;
    email: string | undefined;
    facebook: string | undefined;
    diaChi: string | undefined;
    location: string | undefined;
}

export class PagedResultDtoOfKhachHangDto implements IPagedResultDtoOfKhachHangDto {
    totalCount: number | undefined;
    items: KhachHangDto[] | undefined;

    constructor(data?: IPagedResultDtoOfKhachHangDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(KhachHangDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfKhachHangDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfKhachHangDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfKhachHangDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfKhachHangDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfKhachHangDto {
    totalCount: number | undefined;
    items: KhachHangDto[] | undefined;
}

export class KhachHangDto implements IKhachHangDto {
    name: string | undefined;
    birthday: moment.Moment | undefined;
    phoneNumber: string | undefined;
    emailAddress: string | undefined;
    address: string | undefined;
    districtId: number | undefined;
    provinceId: number | undefined;
    location: string | undefined;
    description: string | undefined;
    userId: number | undefined;
    userName: string | undefined;
    addressFull: string | undefined;
    isActived: boolean | undefined;
    isLocked: boolean | undefined;
    status: string | undefined;
    id: number | undefined;

    constructor(data?: IKhachHangDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.birthday = data["birthday"] ? moment(data["birthday"].toString()) : <any>undefined;
            this.phoneNumber = data["phoneNumber"];
            this.emailAddress = data["emailAddress"];
            this.address = data["address"];
            this.districtId = data["districtId"];
            this.provinceId = data["provinceId"];
            this.location = data["location"];
            this.description = data["description"];
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.addressFull = data["addressFull"];
            this.isActived = data["isActived"];
            this.isLocked = data["isLocked"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): KhachHangDto {
        data = typeof data === 'object' ? data : {};
        let result = new KhachHangDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber;
        data["emailAddress"] = this.emailAddress;
        data["address"] = this.address;
        data["districtId"] = this.districtId;
        data["provinceId"] = this.provinceId;
        data["location"] = this.location;
        data["description"] = this.description;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["addressFull"] = this.addressFull;
        data["isActived"] = this.isActived;
        data["isLocked"] = this.isLocked;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): KhachHangDto {
        const json = this.toJSON();
        let result = new KhachHangDto();
        result.init(json);
        return result;
    }
}

export interface IKhachHangDto {
    name: string | undefined;
    birthday: moment.Moment | undefined;
    phoneNumber: string | undefined;
    emailAddress: string | undefined;
    address: string | undefined;
    districtId: number | undefined;
    provinceId: number | undefined;
    location: string | undefined;
    description: string | undefined;
    userId: number | undefined;
    userName: string | undefined;
    addressFull: string | undefined;
    isActived: boolean | undefined;
    isLocked: boolean | undefined;
    status: string | undefined;
    id: number | undefined;
}

export class CreateKhachHangDto implements ICreateKhachHangDto {
    name: string | undefined;
    birthday: moment.Moment | undefined;
    phoneNumber: string | undefined;
    emailAddress: string | undefined;
    address: string | undefined;
    districtId: number | undefined;
    provinceId: number | undefined;
    location: string | undefined;
    description: string | undefined;
    password: string | undefined;

    constructor(data?: ICreateKhachHangDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.birthday = data["birthday"] ? moment(data["birthday"].toString()) : <any>undefined;
            this.phoneNumber = data["phoneNumber"];
            this.emailAddress = data["emailAddress"];
            this.address = data["address"];
            this.districtId = data["districtId"];
            this.provinceId = data["provinceId"];
            this.location = data["location"];
            this.description = data["description"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): CreateKhachHangDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateKhachHangDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber;
        data["emailAddress"] = this.emailAddress;
        data["address"] = this.address;
        data["districtId"] = this.districtId;
        data["provinceId"] = this.provinceId;
        data["location"] = this.location;
        data["description"] = this.description;
        data["password"] = this.password;
        return data; 
    }

    clone(): CreateKhachHangDto {
        const json = this.toJSON();
        let result = new CreateKhachHangDto();
        result.init(json);
        return result;
    }
}

export interface ICreateKhachHangDto {
    name: string | undefined;
    birthday: moment.Moment | undefined;
    phoneNumber: string | undefined;
    emailAddress: string | undefined;
    address: string | undefined;
    districtId: number | undefined;
    provinceId: number | undefined;
    location: string | undefined;
    description: string | undefined;
    password: string | undefined;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id: number | undefined;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDtoOfInt64 {
        const json = this.toJSON();
        let result = new EntityDtoOfInt64();
        result.init(json);
        return result;
    }
}

export interface IEntityDtoOfInt64 {
    id: number | undefined;
}

export class LockUnlockInput implements ILockUnlockInput {
    userId: number | undefined;
    isLocked: boolean | undefined;

    constructor(data?: ILockUnlockInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.isLocked = data["isLocked"];
        }
    }

    static fromJS(data: any): LockUnlockInput {
        data = typeof data === 'object' ? data : {};
        let result = new LockUnlockInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["isLocked"] = this.isLocked;
        return data; 
    }

    clone(): LockUnlockInput {
        const json = this.toJSON();
        let result = new LockUnlockInput();
        result.init(json);
        return result;
    }
}

export interface ILockUnlockInput {
    userId: number | undefined;
    isLocked: boolean | undefined;
}

export class SetPasswordDto implements ISetPasswordDto {
    userId: number | undefined;
    password: string | undefined;
    adminPassword: string | undefined;

    constructor(data?: ISetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.password = data["password"];
            this.adminPassword = data["adminPassword"];
        }
    }

    static fromJS(data: any): SetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["password"] = this.password;
        data["adminPassword"] = this.adminPassword;
        return data; 
    }

    clone(): SetPasswordDto {
        const json = this.toJSON();
        let result = new SetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface ISetPasswordDto {
    userId: number | undefined;
    password: string | undefined;
    adminPassword: string | undefined;
}

export class FileDto implements IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }

    clone(): FileDto {
        const json = this.toJSON();
        let result = new FileDto();
        result.init(json);
        return result;
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;
}

export class KhuyenMaiDto implements IKhuyenMaiDto {
    name: string | undefined;
    description: string | undefined;
    content: string | undefined;
    imageBase64: string | undefined;
    id: number | undefined;

    constructor(data?: IKhuyenMaiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.content = data["content"];
            this.imageBase64 = data["imageBase64"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): KhuyenMaiDto {
        data = typeof data === 'object' ? data : {};
        let result = new KhuyenMaiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["content"] = this.content;
        data["imageBase64"] = this.imageBase64;
        data["id"] = this.id;
        return data; 
    }

    clone(): KhuyenMaiDto {
        const json = this.toJSON();
        let result = new KhuyenMaiDto();
        result.init(json);
        return result;
    }
}

export interface IKhuyenMaiDto {
    name: string | undefined;
    description: string | undefined;
    content: string | undefined;
    imageBase64: string | undefined;
    id: number | undefined;
}

export class LookupTableDtoOfInt64 implements ILookupTableDtoOfInt64 {
    id: number | undefined;
    displayName: string | undefined;

    constructor(data?: ILookupTableDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): LookupTableDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new LookupTableDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): LookupTableDtoOfInt64 {
        const json = this.toJSON();
        let result = new LookupTableDtoOfInt64();
        result.init(json);
        return result;
    }
}

export interface ILookupTableDtoOfInt64 {
    id: number | undefined;
    displayName: string | undefined;
}

export class LookupTableDto implements ILookupTableDto {
    id: number | undefined;
    displayName: string | undefined;

    constructor(data?: ILookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): LookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): LookupTableDto {
        const json = this.toJSON();
        let result = new LookupTableDto();
        result.init(json);
        return result;
    }
}

export interface ILookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class GetAllQuanHuyenInput implements IGetAllQuanHuyenInput {
    tinhThanhIds: number[] | undefined;

    constructor(data?: IGetAllQuanHuyenInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["tinhThanhIds"] && data["tinhThanhIds"].constructor === Array) {
                this.tinhThanhIds = [];
                for (let item of data["tinhThanhIds"])
                    this.tinhThanhIds.push(item);
            }
        }
    }

    static fromJS(data: any): GetAllQuanHuyenInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllQuanHuyenInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.tinhThanhIds && this.tinhThanhIds.constructor === Array) {
            data["tinhThanhIds"] = [];
            for (let item of this.tinhThanhIds)
                data["tinhThanhIds"].push(item);
        }
        return data; 
    }

    clone(): GetAllQuanHuyenInput {
        const json = this.toJSON();
        let result = new GetAllQuanHuyenInput();
        result.init(json);
        return result;
    }
}

export interface IGetAllQuanHuyenInput {
    tinhThanhIds: number[] | undefined;
}

export class NhanVienLookupTableDto implements INhanVienLookupTableDto {
    displayName: string | undefined;
    userName: string | undefined;
    id: number | undefined;

    constructor(data?: INhanVienLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.userName = data["userName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): NhanVienLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhanVienLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["userName"] = this.userName;
        data["id"] = this.id;
        return data; 
    }

    clone(): NhanVienLookupTableDto {
        const json = this.toJSON();
        let result = new NhanVienLookupTableDto();
        result.init(json);
        return result;
    }
}

export interface INhanVienLookupTableDto {
    displayName: string | undefined;
    userName: string | undefined;
    id: number | undefined;
}

export class KhachHangLookupTableDto implements IKhachHangLookupTableDto {
    displayName: string | undefined;
    name: string | undefined;
    phoneNumber: string | undefined;
    address: string | undefined;
    provinceId: number | undefined;
    districtId: number | undefined;
    id: number | undefined;

    constructor(data?: IKhachHangLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.name = data["name"];
            this.phoneNumber = data["phoneNumber"];
            this.address = data["address"];
            this.provinceId = data["provinceId"];
            this.districtId = data["districtId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): KhachHangLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new KhachHangLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        data["provinceId"] = this.provinceId;
        data["districtId"] = this.districtId;
        data["id"] = this.id;
        return data; 
    }

    clone(): KhachHangLookupTableDto {
        const json = this.toJSON();
        let result = new KhachHangLookupTableDto();
        result.init(json);
        return result;
    }
}

export interface IKhachHangLookupTableDto {
    displayName: string | undefined;
    name: string | undefined;
    phoneNumber: string | undefined;
    address: string | undefined;
    provinceId: number | undefined;
    districtId: number | undefined;
    id: number | undefined;
}

export class HangMucLookupTableDto implements IHangMucLookupTableDto {
    displayName: string | undefined;
    name: string | undefined;
    donViTinh: string | undefined;
    donGia: number | undefined;
    id: number | undefined;

    constructor(data?: IHangMucLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.name = data["name"];
            this.donViTinh = data["donViTinh"];
            this.donGia = data["donGia"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): HangMucLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new HangMucLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["donViTinh"] = this.donViTinh;
        data["donGia"] = this.donGia;
        data["id"] = this.id;
        return data; 
    }

    clone(): HangMucLookupTableDto {
        const json = this.toJSON();
        let result = new HangMucLookupTableDto();
        result.init(json);
        return result;
    }
}

export interface IHangMucLookupTableDto {
    displayName: string | undefined;
    name: string | undefined;
    donViTinh: string | undefined;
    donGia: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfCongViecDto implements IPagedResultDtoOfCongViecDto {
    totalCount: number | undefined;
    items: CongViecDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCongViecDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CongViecDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCongViecDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCongViecDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCongViecDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCongViecDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCongViecDto {
    totalCount: number | undefined;
    items: CongViecDto[] | undefined;
}

export class CreateCongViecDto implements ICreateCongViecDto {
    tieuDe: string | undefined;
    noiDung: string | undefined;
    ghiChuNhanVien: string | undefined;
    dichVuId: number | undefined;
    phuPhi: number | undefined;
    thanhTien: number | undefined;
    tramDichVuId: number | undefined;
    nhanVienId: number | undefined;
    khachHangId: number | undefined;
    khachHangName: string | undefined;
    ngayGioHen: moment.Moment | undefined;
    soDienThoai: string | undefined;
    diaChi: string | undefined;
    diaChiQuanHuyenId: number | undefined;
    diaChiTinhThanhId: number | undefined;
    location: string | undefined;
    lyDoHuy: string | undefined;
    trangThaiId: number | undefined;
    loaiCongViecId: number | undefined;

    constructor(data?: ICreateCongViecDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tieuDe = data["tieuDe"];
            this.noiDung = data["noiDung"];
            this.ghiChuNhanVien = data["ghiChuNhanVien"];
            this.dichVuId = data["dichVuId"];
            this.phuPhi = data["phuPhi"];
            this.thanhTien = data["thanhTien"];
            this.tramDichVuId = data["tramDichVuId"];
            this.nhanVienId = data["nhanVienId"];
            this.khachHangId = data["khachHangId"];
            this.khachHangName = data["khachHangName"];
            this.ngayGioHen = data["ngayGioHen"] ? moment(data["ngayGioHen"].toString()) : <any>undefined;
            this.soDienThoai = data["soDienThoai"];
            this.diaChi = data["diaChi"];
            this.diaChiQuanHuyenId = data["diaChiQuanHuyenId"];
            this.diaChiTinhThanhId = data["diaChiTinhThanhId"];
            this.location = data["location"];
            this.lyDoHuy = data["lyDoHuy"];
            this.trangThaiId = data["trangThaiId"];
            this.loaiCongViecId = data["loaiCongViecId"];
        }
    }

    static fromJS(data: any): CreateCongViecDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCongViecDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tieuDe"] = this.tieuDe;
        data["noiDung"] = this.noiDung;
        data["ghiChuNhanVien"] = this.ghiChuNhanVien;
        data["dichVuId"] = this.dichVuId;
        data["phuPhi"] = this.phuPhi;
        data["thanhTien"] = this.thanhTien;
        data["tramDichVuId"] = this.tramDichVuId;
        data["nhanVienId"] = this.nhanVienId;
        data["khachHangId"] = this.khachHangId;
        data["khachHangName"] = this.khachHangName;
        data["ngayGioHen"] = this.ngayGioHen ? this.ngayGioHen.toISOString() : <any>undefined;
        data["soDienThoai"] = this.soDienThoai;
        data["diaChi"] = this.diaChi;
        data["diaChiQuanHuyenId"] = this.diaChiQuanHuyenId;
        data["diaChiTinhThanhId"] = this.diaChiTinhThanhId;
        data["location"] = this.location;
        data["lyDoHuy"] = this.lyDoHuy;
        data["trangThaiId"] = this.trangThaiId;
        data["loaiCongViecId"] = this.loaiCongViecId;
        return data; 
    }

    clone(): CreateCongViecDto {
        const json = this.toJSON();
        let result = new CreateCongViecDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCongViecDto {
    tieuDe: string | undefined;
    noiDung: string | undefined;
    ghiChuNhanVien: string | undefined;
    dichVuId: number | undefined;
    phuPhi: number | undefined;
    thanhTien: number | undefined;
    tramDichVuId: number | undefined;
    nhanVienId: number | undefined;
    khachHangId: number | undefined;
    khachHangName: string | undefined;
    ngayGioHen: moment.Moment | undefined;
    soDienThoai: string | undefined;
    diaChi: string | undefined;
    diaChiQuanHuyenId: number | undefined;
    diaChiTinhThanhId: number | undefined;
    location: string | undefined;
    lyDoHuy: string | undefined;
    trangThaiId: number | undefined;
    loaiCongViecId: number | undefined;
}

export class PhanBoVeTramInput implements IPhanBoVeTramInput {
    tramDichVuId: number | undefined;
    congViecIds: number[] | undefined;
    ghiChuQuanLy: string | undefined;

    constructor(data?: IPhanBoVeTramInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tramDichVuId = data["tramDichVuId"];
            if (data["congViecIds"] && data["congViecIds"].constructor === Array) {
                this.congViecIds = [];
                for (let item of data["congViecIds"])
                    this.congViecIds.push(item);
            }
            this.ghiChuQuanLy = data["ghiChuQuanLy"];
        }
    }

    static fromJS(data: any): PhanBoVeTramInput {
        data = typeof data === 'object' ? data : {};
        let result = new PhanBoVeTramInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tramDichVuId"] = this.tramDichVuId;
        if (this.congViecIds && this.congViecIds.constructor === Array) {
            data["congViecIds"] = [];
            for (let item of this.congViecIds)
                data["congViecIds"].push(item);
        }
        data["ghiChuQuanLy"] = this.ghiChuQuanLy;
        return data; 
    }

    clone(): PhanBoVeTramInput {
        const json = this.toJSON();
        let result = new PhanBoVeTramInput();
        result.init(json);
        return result;
    }
}

export interface IPhanBoVeTramInput {
    tramDichVuId: number | undefined;
    congViecIds: number[] | undefined;
    ghiChuQuanLy: string | undefined;
}

export class PhanBoVeNhanVienInput implements IPhanBoVeNhanVienInput {
    tramDichVuId: number | undefined;
    nhanVienId: number | undefined;
    congViecIds: number[] | undefined;
    ghiChuQuanLy: string | undefined;

    constructor(data?: IPhanBoVeNhanVienInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tramDichVuId = data["tramDichVuId"];
            this.nhanVienId = data["nhanVienId"];
            if (data["congViecIds"] && data["congViecIds"].constructor === Array) {
                this.congViecIds = [];
                for (let item of data["congViecIds"])
                    this.congViecIds.push(item);
            }
            this.ghiChuQuanLy = data["ghiChuQuanLy"];
        }
    }

    static fromJS(data: any): PhanBoVeNhanVienInput {
        data = typeof data === 'object' ? data : {};
        let result = new PhanBoVeNhanVienInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tramDichVuId"] = this.tramDichVuId;
        data["nhanVienId"] = this.nhanVienId;
        if (this.congViecIds && this.congViecIds.constructor === Array) {
            data["congViecIds"] = [];
            for (let item of this.congViecIds)
                data["congViecIds"].push(item);
        }
        data["ghiChuQuanLy"] = this.ghiChuQuanLy;
        return data; 
    }

    clone(): PhanBoVeNhanVienInput {
        const json = this.toJSON();
        let result = new PhanBoVeNhanVienInput();
        result.init(json);
        return result;
    }
}

export interface IPhanBoVeNhanVienInput {
    tramDichVuId: number | undefined;
    nhanVienId: number | undefined;
    congViecIds: number[] | undefined;
    ghiChuQuanLy: string | undefined;
}

export class ThuHoiCongViecInput implements IThuHoiCongViecInput {
    congViecId: number | undefined;
    ghiChuQuanLy: string | undefined;

    constructor(data?: IThuHoiCongViecInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.congViecId = data["congViecId"];
            this.ghiChuQuanLy = data["ghiChuQuanLy"];
        }
    }

    static fromJS(data: any): ThuHoiCongViecInput {
        data = typeof data === 'object' ? data : {};
        let result = new ThuHoiCongViecInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["congViecId"] = this.congViecId;
        data["ghiChuQuanLy"] = this.ghiChuQuanLy;
        return data; 
    }

    clone(): ThuHoiCongViecInput {
        const json = this.toJSON();
        let result = new ThuHoiCongViecInput();
        result.init(json);
        return result;
    }
}

export interface IThuHoiCongViecInput {
    congViecId: number | undefined;
    ghiChuQuanLy: string | undefined;
}

export class HuyBoCongViecInput implements IHuyBoCongViecInput {
    congViecId: number | undefined;
    ghiChuQuanLy: string | undefined;

    constructor(data?: IHuyBoCongViecInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.congViecId = data["congViecId"];
            this.ghiChuQuanLy = data["ghiChuQuanLy"];
        }
    }

    static fromJS(data: any): HuyBoCongViecInput {
        data = typeof data === 'object' ? data : {};
        let result = new HuyBoCongViecInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["congViecId"] = this.congViecId;
        data["ghiChuQuanLy"] = this.ghiChuQuanLy;
        return data; 
    }

    clone(): HuyBoCongViecInput {
        const json = this.toJSON();
        let result = new HuyBoCongViecInput();
        result.init(json);
        return result;
    }
}

export interface IHuyBoCongViecInput {
    congViecId: number | undefined;
    ghiChuQuanLy: string | undefined;
}

export class PagedResultDtoOfTinTucDto implements IPagedResultDtoOfTinTucDto {
    totalCount: number | undefined;
    items: TinTucDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTinTucDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TinTucDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTinTucDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTinTucDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTinTucDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTinTucDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTinTucDto {
    totalCount: number | undefined;
    items: TinTucDto[] | undefined;
}

export class TinTucDto implements ITinTucDto {
    name: string | undefined;
    description: string | undefined;
    content: string | undefined;
    image: string | undefined;
    imageBase64: string | undefined;
    type: number | undefined;
    isActive: boolean | undefined;
    id: number | undefined;

    constructor(data?: ITinTucDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.content = data["content"];
            this.image = data["image"];
            this.imageBase64 = data["imageBase64"];
            this.type = data["type"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TinTucDto {
        data = typeof data === 'object' ? data : {};
        let result = new TinTucDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["content"] = this.content;
        data["image"] = this.image;
        data["imageBase64"] = this.imageBase64;
        data["type"] = this.type;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): TinTucDto {
        const json = this.toJSON();
        let result = new TinTucDto();
        result.init(json);
        return result;
    }
}

export interface ITinTucDto {
    name: string | undefined;
    description: string | undefined;
    content: string | undefined;
    image: string | undefined;
    imageBase64: string | undefined;
    type: number | undefined;
    isActive: boolean | undefined;
    id: number | undefined;
}

export class CreateTinTucDto implements ICreateTinTucDto {
    name: string | undefined;
    description: string | undefined;
    content: string | undefined;
    image: string | undefined;
    imageBase64: string | undefined;
    type: number | undefined;
    isActive: boolean | undefined;

    constructor(data?: ICreateTinTucDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.content = data["content"];
            this.image = data["image"];
            this.imageBase64 = data["imageBase64"];
            this.type = data["type"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): CreateTinTucDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTinTucDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["content"] = this.content;
        data["image"] = this.image;
        data["imageBase64"] = this.imageBase64;
        data["type"] = this.type;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateTinTucDto {
        const json = this.toJSON();
        let result = new CreateTinTucDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTinTucDto {
    name: string | undefined;
    description: string | undefined;
    content: string | undefined;
    image: string | undefined;
    imageBase64: string | undefined;
    type: number | undefined;
    isActive: boolean | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    permissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data; 
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    permissions: string[] | undefined;
}

export class RoleDto implements IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    permissions: string[] | undefined;
    isDefault: boolean | undefined;
    id: number | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
            this.isDefault = data["isDefault"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["isDefault"] = this.isDefault;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    permissions: string[] | undefined;
    isDefault: boolean | undefined;
    id: number | undefined;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfRoleListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class ListResultDtoOfPermissionDto implements IListResultDtoOfPermissionDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IListResultDtoOfPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfPermissionDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfPermissionDto {
    items: PermissionDto[] | undefined;
}

export class PermissionDto implements IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean | undefined;
    id: number | undefined;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isStatic = data["isStatic"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean | undefined;
    id: number | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data; 
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class PagedResultDtoOfRoleDto implements IPagedResultDtoOfRoleDto {
    totalCount: number | undefined;
    items: RoleDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfRoleDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRoleDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRoleDto {
    totalCount: number | undefined;
    items: RoleDto[] | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto | undefined;
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto | undefined;
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    androidVersion: string | undefined;
    iosVersion: string | undefined;
    releaseDate: moment.Moment | undefined;
    features: { [key: string] : boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.androidVersion = data["androidVersion"];
            this.iosVersion = data["iosVersion"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["androidVersion"] = this.androidVersion;
        data["iosVersion"] = this.iosVersion;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    androidVersion: string | undefined;
    iosVersion: string | undefined;
    releaseDate: moment.Moment | undefined;
    features: { [key: string] : boolean; } | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureBase64: string | undefined;
    id: number | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureBase64 = data["profilePictureBase64"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureBase64"] = this.profilePictureBase64;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureBase64: string | undefined;
    id: number | undefined;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number | undefined;
}

export class SoBaoHanhDto implements ISoBaoHanhDto {
    name: string | undefined;
    soSerial: string | undefined;
    hang: string | undefined;
    quanTam: boolean | undefined;
    ngayMua: moment.Moment | undefined;
    soThangBaoHanh: number | undefined;
    imageBase64: string | undefined;
    soNgayConBaoHanh: number | undefined;
    id: number | undefined;

    constructor(data?: ISoBaoHanhDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.soSerial = data["soSerial"];
            this.hang = data["hang"];
            this.quanTam = data["quanTam"];
            this.ngayMua = data["ngayMua"] ? moment(data["ngayMua"].toString()) : <any>undefined;
            this.soThangBaoHanh = data["soThangBaoHanh"];
            this.imageBase64 = data["imageBase64"];
            this.soNgayConBaoHanh = data["soNgayConBaoHanh"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SoBaoHanhDto {
        data = typeof data === 'object' ? data : {};
        let result = new SoBaoHanhDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["soSerial"] = this.soSerial;
        data["hang"] = this.hang;
        data["quanTam"] = this.quanTam;
        data["ngayMua"] = this.ngayMua ? this.ngayMua.toISOString() : <any>undefined;
        data["soThangBaoHanh"] = this.soThangBaoHanh;
        data["imageBase64"] = this.imageBase64;
        data["soNgayConBaoHanh"] = this.soNgayConBaoHanh;
        data["id"] = this.id;
        return data; 
    }

    clone(): SoBaoHanhDto {
        const json = this.toJSON();
        let result = new SoBaoHanhDto();
        result.init(json);
        return result;
    }
}

export interface ISoBaoHanhDto {
    name: string | undefined;
    soSerial: string | undefined;
    hang: string | undefined;
    quanTam: boolean | undefined;
    ngayMua: moment.Moment | undefined;
    soThangBaoHanh: number | undefined;
    imageBase64: string | undefined;
    soNgayConBaoHanh: number | undefined;
    id: number | undefined;
}

export class CreateSoBaoHanhDto implements ICreateSoBaoHanhDto {
    name: string | undefined;
    soSerial: string | undefined;
    hang: string | undefined;
    quanTam: boolean | undefined;
    ngayMua: moment.Moment | undefined;
    soThangBaoHanh: number | undefined;
    imageBase64: string | undefined;
    image: string | undefined;

    constructor(data?: ICreateSoBaoHanhDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.soSerial = data["soSerial"];
            this.hang = data["hang"];
            this.quanTam = data["quanTam"];
            this.ngayMua = data["ngayMua"] ? moment(data["ngayMua"].toString()) : <any>undefined;
            this.soThangBaoHanh = data["soThangBaoHanh"];
            this.imageBase64 = data["imageBase64"];
            this.image = data["image"];
        }
    }

    static fromJS(data: any): CreateSoBaoHanhDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSoBaoHanhDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["soSerial"] = this.soSerial;
        data["hang"] = this.hang;
        data["quanTam"] = this.quanTam;
        data["ngayMua"] = this.ngayMua ? this.ngayMua.toISOString() : <any>undefined;
        data["soThangBaoHanh"] = this.soThangBaoHanh;
        data["imageBase64"] = this.imageBase64;
        data["image"] = this.image;
        return data; 
    }

    clone(): CreateSoBaoHanhDto {
        const json = this.toJSON();
        let result = new CreateSoBaoHanhDto();
        result.init(json);
        return result;
    }
}

export interface ICreateSoBaoHanhDto {
    name: string | undefined;
    soSerial: string | undefined;
    hang: string | undefined;
    quanTam: boolean | undefined;
    ngayMua: moment.Moment | undefined;
    soThangBaoHanh: number | undefined;
    imageBase64: string | undefined;
    image: string | undefined;
}

export class QuanTamInput implements IQuanTamInput {
    quanTam: boolean | undefined;
    id: number | undefined;

    constructor(data?: IQuanTamInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.quanTam = data["quanTam"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuanTamInput {
        data = typeof data === 'object' ? data : {};
        let result = new QuanTamInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quanTam"] = this.quanTam;
        data["id"] = this.id;
        return data; 
    }

    clone(): QuanTamInput {
        const json = this.toJSON();
        let result = new QuanTamInput();
        result.init(json);
        return result;
    }
}

export interface IQuanTamInput {
    quanTam: boolean | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfSoBaoHanhDto implements IPagedResultDtoOfSoBaoHanhDto {
    totalCount: number | undefined;
    items: SoBaoHanhDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSoBaoHanhDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SoBaoHanhDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSoBaoHanhDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSoBaoHanhDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfSoBaoHanhDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfSoBaoHanhDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfSoBaoHanhDto {
    totalCount: number | undefined;
    items: SoBaoHanhDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean | undefined;
    isCustomer: boolean | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.rememberClient = data["rememberClient"];
            this.isCustomer = data["isCustomer"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        data["isCustomer"] = this.isCustomer;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean | undefined;
    isCustomer: boolean | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    userId: number | undefined;
    userName: string | undefined;
    name: string | undefined;
    phoneNumber: string | undefined;
    emailAddress: string | undefined;
    profilePicture: string | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.name = data["name"];
            this.phoneNumber = data["phoneNumber"];
            this.emailAddress = data["emailAddress"];
            this.profilePicture = data["profilePicture"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["phoneNumber"] = this.phoneNumber;
        data["emailAddress"] = this.emailAddress;
        data["profilePicture"] = this.profilePicture;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    userId: number | undefined;
    userName: string | undefined;
    name: string | undefined;
    phoneNumber: string | undefined;
    emailAddress: string | undefined;
    profilePicture: string | undefined;
}

export class PagedResultDtoOfGetTramDichVuForView implements IPagedResultDtoOfGetTramDichVuForView {
    totalCount: number | undefined;
    items: GetTramDichVuForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTramDichVuForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetTramDichVuForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTramDichVuForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTramDichVuForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetTramDichVuForView {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetTramDichVuForView();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetTramDichVuForView {
    totalCount: number | undefined;
    items: GetTramDichVuForView[] | undefined;
}

export class GetTramDichVuForView implements IGetTramDichVuForView {
    tramDichVu: TramDichVuDto | undefined;
    tramTruongName: string | undefined;
    diaChi: string | undefined;

    constructor(data?: IGetTramDichVuForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tramDichVu = data["tramDichVu"] ? TramDichVuDto.fromJS(data["tramDichVu"]) : <any>undefined;
            this.tramTruongName = data["tramTruongName"];
            this.diaChi = data["diaChi"];
        }
    }

    static fromJS(data: any): GetTramDichVuForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetTramDichVuForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tramDichVu"] = this.tramDichVu ? this.tramDichVu.toJSON() : <any>undefined;
        data["tramTruongName"] = this.tramTruongName;
        data["diaChi"] = this.diaChi;
        return data; 
    }

    clone(): GetTramDichVuForView {
        const json = this.toJSON();
        let result = new GetTramDichVuForView();
        result.init(json);
        return result;
    }
}

export interface IGetTramDichVuForView {
    tramDichVu: TramDichVuDto | undefined;
    tramTruongName: string | undefined;
    diaChi: string | undefined;
}

export class TramDichVuDto implements ITramDichVuDto {
    code: string;
    name: string;
    tramTruongId: number;
    diaChi: string | undefined;
    diaChiQuanHuyenId: number | undefined;
    diaChiTinhThanhId: number | undefined;
    ngayHoatDong: moment.Moment | undefined;
    description: string | undefined;
    userIds: number[] | undefined;
    id: number | undefined;

    constructor(data?: ITramDichVuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.tramTruongId = data["tramTruongId"];
            this.diaChi = data["diaChi"];
            this.diaChiQuanHuyenId = data["diaChiQuanHuyenId"];
            this.diaChiTinhThanhId = data["diaChiTinhThanhId"];
            this.ngayHoatDong = data["ngayHoatDong"] ? moment(data["ngayHoatDong"].toString()) : <any>undefined;
            this.description = data["description"];
            if (data["userIds"] && data["userIds"].constructor === Array) {
                this.userIds = [];
                for (let item of data["userIds"])
                    this.userIds.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TramDichVuDto {
        data = typeof data === 'object' ? data : {};
        let result = new TramDichVuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["tramTruongId"] = this.tramTruongId;
        data["diaChi"] = this.diaChi;
        data["diaChiQuanHuyenId"] = this.diaChiQuanHuyenId;
        data["diaChiTinhThanhId"] = this.diaChiTinhThanhId;
        data["ngayHoatDong"] = this.ngayHoatDong ? this.ngayHoatDong.toISOString() : <any>undefined;
        data["description"] = this.description;
        if (this.userIds && this.userIds.constructor === Array) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): TramDichVuDto {
        const json = this.toJSON();
        let result = new TramDichVuDto();
        result.init(json);
        return result;
    }
}

export interface ITramDichVuDto {
    code: string;
    name: string;
    tramTruongId: number;
    diaChi: string | undefined;
    diaChiQuanHuyenId: number | undefined;
    diaChiTinhThanhId: number | undefined;
    ngayHoatDong: moment.Moment | undefined;
    description: string | undefined;
    userIds: number[] | undefined;
    id: number | undefined;
}

export class CreateTramDichVuDto implements ICreateTramDichVuDto {
    code: string;
    name: string;
    tramTruongId: number;
    diaChi: string | undefined;
    diaChiQuanHuyenId: number | undefined;
    diaChiTinhThanhId: number | undefined;
    ngayHoatDong: moment.Moment | undefined;
    description: string | undefined;
    userIds: number[] | undefined;

    constructor(data?: ICreateTramDichVuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.tramTruongId = data["tramTruongId"];
            this.diaChi = data["diaChi"];
            this.diaChiQuanHuyenId = data["diaChiQuanHuyenId"];
            this.diaChiTinhThanhId = data["diaChiTinhThanhId"];
            this.ngayHoatDong = data["ngayHoatDong"] ? moment(data["ngayHoatDong"].toString()) : <any>undefined;
            this.description = data["description"];
            if (data["userIds"] && data["userIds"].constructor === Array) {
                this.userIds = [];
                for (let item of data["userIds"])
                    this.userIds.push(item);
            }
        }
    }

    static fromJS(data: any): CreateTramDichVuDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTramDichVuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["tramTruongId"] = this.tramTruongId;
        data["diaChi"] = this.diaChi;
        data["diaChiQuanHuyenId"] = this.diaChiQuanHuyenId;
        data["diaChiTinhThanhId"] = this.diaChiTinhThanhId;
        data["ngayHoatDong"] = this.ngayHoatDong ? this.ngayHoatDong.toISOString() : <any>undefined;
        data["description"] = this.description;
        if (this.userIds && this.userIds.constructor === Array) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        return data; 
    }

    clone(): CreateTramDichVuDto {
        const json = this.toJSON();
        let result = new CreateTramDichVuDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTramDichVuDto {
    code: string;
    name: string;
    tramTruongId: number;
    diaChi: string | undefined;
    diaChiQuanHuyenId: number | undefined;
    diaChiTinhThanhId: number | undefined;
    ngayHoatDong: moment.Moment | undefined;
    description: string | undefined;
    userIds: number[] | undefined;
}

export class PagedResultDtoOfTramDichVuDto implements IPagedResultDtoOfTramDichVuDto {
    totalCount: number | undefined;
    items: TramDichVuDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTramDichVuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TramDichVuDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTramDichVuDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTramDichVuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTramDichVuDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTramDichVuDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTramDichVuDto {
    totalCount: number | undefined;
    items: TramDichVuDto[] | undefined;
}

export class UserDto implements IUserDto {
    userName: string;
    name: string;
    emailAddress: string;
    phoneNumber: string;
    isCustomer: boolean | undefined;
    tramDichVuId: number | undefined;
    nhomDichVuIds: number[] | undefined;
    phuTrachTinhThanhIds: number[] | undefined;
    phuTrachQuanHuyenIds: number[] | undefined;
    birthday: moment.Moment | undefined;
    isActive: boolean | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
    profilePictureBase64: string | undefined;
    description: string | undefined;
    id: number | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.isCustomer = data["isCustomer"];
            this.tramDichVuId = data["tramDichVuId"];
            if (data["nhomDichVuIds"] && data["nhomDichVuIds"].constructor === Array) {
                this.nhomDichVuIds = [];
                for (let item of data["nhomDichVuIds"])
                    this.nhomDichVuIds.push(item);
            }
            if (data["phuTrachTinhThanhIds"] && data["phuTrachTinhThanhIds"].constructor === Array) {
                this.phuTrachTinhThanhIds = [];
                for (let item of data["phuTrachTinhThanhIds"])
                    this.phuTrachTinhThanhIds.push(item);
            }
            if (data["phuTrachQuanHuyenIds"] && data["phuTrachQuanHuyenIds"].constructor === Array) {
                this.phuTrachQuanHuyenIds = [];
                for (let item of data["phuTrachQuanHuyenIds"])
                    this.phuTrachQuanHuyenIds.push(item);
            }
            this.birthday = data["birthday"] ? moment(data["birthday"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.profilePictureBase64 = data["profilePictureBase64"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isCustomer"] = this.isCustomer;
        data["tramDichVuId"] = this.tramDichVuId;
        if (this.nhomDichVuIds && this.nhomDichVuIds.constructor === Array) {
            data["nhomDichVuIds"] = [];
            for (let item of this.nhomDichVuIds)
                data["nhomDichVuIds"].push(item);
        }
        if (this.phuTrachTinhThanhIds && this.phuTrachTinhThanhIds.constructor === Array) {
            data["phuTrachTinhThanhIds"] = [];
            for (let item of this.phuTrachTinhThanhIds)
                data["phuTrachTinhThanhIds"].push(item);
        }
        if (this.phuTrachQuanHuyenIds && this.phuTrachQuanHuyenIds.constructor === Array) {
            data["phuTrachQuanHuyenIds"] = [];
            for (let item of this.phuTrachQuanHuyenIds)
                data["phuTrachQuanHuyenIds"].push(item);
        }
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["profilePictureBase64"] = this.profilePictureBase64;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string;
    name: string;
    emailAddress: string;
    phoneNumber: string;
    isCustomer: boolean | undefined;
    tramDichVuId: number | undefined;
    nhomDichVuIds: number[] | undefined;
    phuTrachTinhThanhIds: number[] | undefined;
    phuTrachQuanHuyenIds: number[] | undefined;
    birthday: moment.Moment | undefined;
    isActive: boolean | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
    profilePictureBase64: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetUserForView implements IPagedResultDtoOfGetUserForView {
    totalCount: number | undefined;
    items: GetUserForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetUserForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetUserForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetUserForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetUserForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetUserForView {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetUserForView();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetUserForView {
    totalCount: number | undefined;
    items: GetUserForView[] | undefined;
}

export class GetUserForView implements IGetUserForView {
    user: UserDto | undefined;
    tramDichVuName: string | undefined;
    vaiTroName: string | undefined;

    constructor(data?: IGetUserForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserDto.fromJS(data["user"]) : <any>undefined;
            this.tramDichVuName = data["tramDichVuName"];
            this.vaiTroName = data["vaiTroName"];
        }
    }

    static fromJS(data: any): GetUserForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tramDichVuName"] = this.tramDichVuName;
        data["vaiTroName"] = this.vaiTroName;
        return data; 
    }

    clone(): GetUserForView {
        const json = this.toJSON();
        let result = new GetUserForView();
        result.init(json);
        return result;
    }
}

export interface IGetUserForView {
    user: UserDto | undefined;
    tramDichVuName: string | undefined;
    vaiTroName: string | undefined;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    emailAddress: string;
    isActive: boolean | undefined;
    roleNames: string[] | undefined;
    password: string;
    birthday: moment.Moment | undefined;
    profilePictureBase64: string | undefined;
    description: string | undefined;
    phoneNumber: string | undefined;
    isCustomer: boolean | undefined;
    tramDichVuId: number | undefined;
    nhomDichVuIds: number[] | undefined;
    phuTrachTinhThanhIds: number[] | undefined;
    phuTrachQuanHuyenIds: number[] | undefined;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = data["password"];
            this.birthday = data["birthday"] ? moment(data["birthday"].toString()) : <any>undefined;
            this.profilePictureBase64 = data["profilePictureBase64"];
            this.description = data["description"];
            this.phoneNumber = data["phoneNumber"];
            this.isCustomer = data["isCustomer"];
            this.tramDichVuId = data["tramDichVuId"];
            if (data["nhomDichVuIds"] && data["nhomDichVuIds"].constructor === Array) {
                this.nhomDichVuIds = [];
                for (let item of data["nhomDichVuIds"])
                    this.nhomDichVuIds.push(item);
            }
            if (data["phuTrachTinhThanhIds"] && data["phuTrachTinhThanhIds"].constructor === Array) {
                this.phuTrachTinhThanhIds = [];
                for (let item of data["phuTrachTinhThanhIds"])
                    this.phuTrachTinhThanhIds.push(item);
            }
            if (data["phuTrachQuanHuyenIds"] && data["phuTrachQuanHuyenIds"].constructor === Array) {
                this.phuTrachQuanHuyenIds = [];
                for (let item of data["phuTrachQuanHuyenIds"])
                    this.phuTrachQuanHuyenIds.push(item);
            }
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["profilePictureBase64"] = this.profilePictureBase64;
        data["description"] = this.description;
        data["phoneNumber"] = this.phoneNumber;
        data["isCustomer"] = this.isCustomer;
        data["tramDichVuId"] = this.tramDichVuId;
        if (this.nhomDichVuIds && this.nhomDichVuIds.constructor === Array) {
            data["nhomDichVuIds"] = [];
            for (let item of this.nhomDichVuIds)
                data["nhomDichVuIds"].push(item);
        }
        if (this.phuTrachTinhThanhIds && this.phuTrachTinhThanhIds.constructor === Array) {
            data["phuTrachTinhThanhIds"] = [];
            for (let item of this.phuTrachTinhThanhIds)
                data["phuTrachTinhThanhIds"].push(item);
        }
        if (this.phuTrachQuanHuyenIds && this.phuTrachQuanHuyenIds.constructor === Array) {
            data["phuTrachQuanHuyenIds"] = [];
            for (let item of this.phuTrachQuanHuyenIds)
                data["phuTrachQuanHuyenIds"].push(item);
        }
        return data; 
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    emailAddress: string;
    isActive: boolean | undefined;
    roleNames: string[] | undefined;
    password: string;
    birthday: moment.Moment | undefined;
    profilePictureBase64: string | undefined;
    description: string | undefined;
    phoneNumber: string | undefined;
    isCustomer: boolean | undefined;
    tramDichVuId: number | undefined;
    nhomDichVuIds: number[] | undefined;
    phuTrachTinhThanhIds: number[] | undefined;
    phuTrachQuanHuyenIds: number[] | undefined;
}

export class ListResultDtoOfRoleDto implements IListResultDtoOfRoleDto {
    items: RoleDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfRoleDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleDto {
    items: RoleDto[] | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.adminPassword = data["adminPassword"];
            this.userId = data["userId"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export class PagedResultDtoOfUserDto implements IPagedResultDtoOfUserDto {
    totalCount: number | undefined;
    items: UserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfUserDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserDto {
    totalCount: number | undefined;
    items: UserDto[] | undefined;
}

export enum IsTenantAvailableOutputState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}